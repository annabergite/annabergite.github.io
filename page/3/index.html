<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.23.2","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="记录博客与成长,Java，架构">
<meta property="og:type" content="website">
<meta property="og:title" content="艾迪的技术之路">
<meta property="og:url" content="http://example.com/page/3/index.html">
<meta property="og:site_name" content="艾迪的技术之路">
<meta property="og:description" content="记录博客与成长,Java，架构">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="annabergite">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/page/3/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/3/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>艾迪的技术之路</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  

  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/11.7.0/mermaid.min.js","integrity":"sha256-4+IKDqhZ/sXjc8Wtl2/MsxI4e0s1KpEVdbEP7V/Lz8U="}}</script>
  <script src="/js/third-party/tags/mermaid.js" defer></script>





  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">艾迪的技术之路</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">记录博客与成长</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>







</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">annabergite</p>
  <div class="site-description" itemprop="description">记录博客与成长,Java，架构</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">29</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/07/12/%E5%BC%80%E5%8F%91/6.redisson%E4%BD%BF%E7%94%A8lock%E5%AF%BC%E8%87%B4%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="annabergite">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="艾迪的技术之路">
      <meta itemprop="description" content="记录博客与成长,Java，架构">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 艾迪的技术之路">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/07/12/%E5%BC%80%E5%8F%91/6.redisson%E4%BD%BF%E7%94%A8lock%E5%AF%BC%E8%87%B4%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">redisson使用lock导致死锁问题</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-07-12 12:14:50 / 修改时间：23:16:11" itemprop="dateCreated datePublished" datetime="2025-07-12T12:14:50+08:00">2025-07-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">开发</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">问题处理</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="1、背景">1、背景</h2>
<p>我们是做物联网设备的公司，设备初始化会向设备发送API接口下发agora license，当时当时一个环境的全部agora设备都下发出现了问题，具体表现为：</p>
<ol>
<li>当前的线程池告警持续触发拒绝策略（调度线程处理任务），导致运维要求我们进行排查</li>
<li>线程池资源告警则增加资源，环境中agora微服务已经增加到了6台，但是仍然线程的队列容量稳步上升，增加资源并不能解决问题</li>
<li>因为任务队列容量较多，导致大量agora设备下发agora都是在初始化的5-6h以后了，涉及设备面广，影响较大</li>
</ol>
<h2 id="2、排查方式">2、排查方式</h2>
<ol>
<li>使用 jstack 1查看当前的线程池开头的线程状态与堆栈</li>
<li>发现全部的线程池的线程状态都是WATING状态，查看堆栈，都是在等待Redisson的锁释放</li>
<li>查看了下对应线程池设计的流程，发现在下发license时确实会tongguolock方法加锁</li>
<li>查看 腾讯云 日志，发现同一台设备在日志中频繁向设备下发agora license，10s一次，正常流程应当至少2min才初始化下发一次</li>
</ol>
<h3 id="经过逻辑分析后发现原因：">经过逻辑分析后发现原因：</h3>
<p>多个设备出故障频繁注册+redisson.lock() 强制等待锁释放造成线程池资源耗尽</p>
<ol>
<li>
<p>以设备20252025为例，当下发设备license时，第一次会创建一个20252025的锁，但是这个设备也有其他在线程池的进程进行下发，因为使用的是lock，是无限期等待锁，所以线程池资源来利用不起来，导致触发拒绝策略</p>
<p>redisson创建分布式锁的lua脚本是</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Lua 脚本（原子执行）</span></span><br><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">&#x27;exists&#x27;</span>, KEYS[<span class="number">1</span>]) == <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">    redis.call(<span class="string">&#x27;hset&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">2</span>], <span class="number">1</span>);</span><br><span class="line">    redis.call(<span class="string">&#x27;pexpire&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">&#x27;hexists&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">2</span>]) == <span class="number">1</span>) <span class="keyword">then</span></span><br><span class="line">    redis.call(<span class="string">&#x27;hincrby&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">2</span>], <span class="number">1</span>);</span><br><span class="line">    redis.call(<span class="string">&#x27;pexpire&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">return</span> redis.call(<span class="string">&#x27;pttl&#x27;</span>, KEYS[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure>
<p>可以看到value值（Value）的结构：<br>
锁的值存储的是一个字符串（String），内容为锁<br>
持有者的唯一标识符和可重入计数，格式为：<br>
<UUID>:<ThreadID>:<Count><br>
·UUID：Redisson客户端实例的唯一标识符（每个客户端启动时生成）<br>
·ThreadID：持有锁的线程ID（支持可重入锁 同一线程多次加锁）<br>
·Count：锁的可重入次数（初始为1，每次重入加1，释放时减1)</p>
<p>uuid为啥不变 估摸着是服务pod没被杀 自己拉起来时候 这个客户端id不变导致的</p>
</li>
<li>
<p>在某一次的k8s滚动更新时，可能因为未在对应时间内执行完线程池任务（如最后30s等待关闭时间内，虽然没有新任务进，但是进程1在最后1s释放了锁，进程2在此时拿到了锁），导致finally代码块的解锁逻辑并未执行，导致该锁一直被占用，新pod启动后又给redLock续期导致该锁一直没有被释放</p>
</li>
</ol>
<p>因为这两个原因导致线上出现问题</p>
<h2 id="3、解决方式">3、解决方式</h2>
<ol>
<li>不能使用lock方法而是tryLock，等待一段时间后释放掉锁；并依据业务重要程度业务补救（如本次获取不到锁，很可能是因为当前有正在下发的任务，顾不需要延时任务或者持久化这种补救代码逻辑）</li>
<li>推广一下，其他组件如ReentrantLock也有lock和trylock方法，在开发时也尽量使用tryLock</li>
</ol>
<h2 id="扩展阅读">扩展阅读</h2>
<ol>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904152850497543">Java程序员必备：jstack命令解析</a></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/07/12/%E8%AE%BE%E8%AE%A1/2.%E6%80%8E%E4%B9%88%E6%A0%B9%E6%8D%AE%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9B%91%E6%8E%A7%E5%91%8A%E8%AD%A6%E5%AE%9A%E9%87%8F%E4%BF%AE%E6%94%B9%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8F%82%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="annabergite">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="艾迪的技术之路">
      <meta itemprop="description" content="记录博客与成长,Java，架构">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 艾迪的技术之路">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/07/12/%E8%AE%BE%E8%AE%A1/2.%E6%80%8E%E4%B9%88%E6%A0%B9%E6%8D%AE%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9B%91%E6%8E%A7%E5%91%8A%E8%AD%A6%E5%AE%9A%E9%87%8F%E4%BF%AE%E6%94%B9%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8F%82%E6%95%B0/" class="post-title-link" itemprop="url">怎么根据线程池监控告警定量修改线程池参数</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-07-12 12:14:50 / 修改时间：23:16:11" itemprop="dateCreated datePublished" datetime="2025-07-12T12:14:50+08:00">2025-07-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index"><span itemprop="name">设计</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>前置：</p>
<ol>
<li>使用spring项目进行开发</li>
<li>使用线程池进行项目开发</li>
<li>有dynamic-tp或者Hippo4J或者其他有以下告警检测的工具对线程池进行监控</li>
<li>（最好）有运维团队或者运维方面配置</li>
</ol>
<p>任务：</p>
<ol>
<li>触发告警后怎么修改线程池参数和线程池告警参数（重要）</li>
<li>有哪些需要的线程池告警</li>
<li>线程池告警阈值和线程池参数怎么设置</li>
<li>触发告警后怎么排查</li>
<li>怎么根据业务增长重新修改资源与线程池参数</li>
</ol>
<p>常见线程池告警类型如下，本文也从以下几个方面进行展示：</p>
<p><img src="https://hexo-1304698044.cos.ap-shanghai.myqcloud.com/blog/image-20250712122615965.png" alt="image-20250712122615965"></p>
<h2 id="1、触发告警后怎么修改线程池参数和线程池告警参数">1、触发告警后怎么修改线程池参数和线程池告警参数</h2>
<p>先说结论：</p>
<p>根据线程池告警修改参数导图：</p>
<p><img src="https://hexo-1304698044.cos.ap-shanghai.myqcloud.com/blog/image-20250712122624182.png" alt="image-20250712122624182"></p>
<h3 id="1-1、线程活跃度告警">1.1、线程活跃度告警</h3>
<p>释义：任务过多，使得线程池中活跃线程占比超过阈值（如99%）</p>
<p>如果核心线程数&gt;最大线程数*80%：该告警基本上无用，可以不使用</p>
<p>如果核心线程数占最大线程数较小：该告警有一定用处，但是不如其他线程池告警</p>
<h3 id="1-2、队列容量告警">1.2、队列容量告警</h3>
<p>释义：任务过多，达到任务队列容量的阈值（如70%）</p>
<ol>
<li>
<p>如果是任务逐渐处理不过来：</p>
<p>增加pod，增加核心线程数最大线程数，增加任务队列容量</p>
<p>如果是突发任务：</p>
<p>增加任务队列大小容量</p>
</li>
</ol>
<h3 id="1-3、拒绝策略告警">1.3、拒绝策略告警</h3>
<p>释义：任务过多，线程数量达到最大，且任务队列已满，触发线程池拒绝策略</p>
<ol>
<li>
<p>（线程池告警）降低队列容量告警阈值</p>
<p>增加 任务排队超时告警、任务执行超时告警</p>
</li>
<li>
<p>如果是任务逐渐处理不过来：</p>
<p>增加pod，增加核心线程数最大线程数，增加任务队列容量</p>
<p>如果是突发任务：</p>
<p>增加任务队列大小容量</p>
</li>
<li>
<p>优化拒绝策略，尝试自定义拒绝策略（从Netty、Dubbo等框架中学习非JDK8的拒绝策略）</p>
</li>
</ol>
<h3 id="1-4、任务排队超时告警">1.4、任务排队超时告警</h3>
<p>释义：任务从任务队列到线程池中时，时间过长</p>
<p>优化点：</p>
<ol>
<li>
<p>增加核心线程数与最大线程数（如原有数量*2）</p>
</li>
<li>
<p>（其他）单个任务逻辑，优化可以从异步，并发等方面入手</p>
<p>增加pod数量</p>
</li>
</ol>
<h3 id="1-5、任务执行超时告警">1.5、任务执行超时告警</h3>
<p>释义：执行期间单个任务直接放入线程中执行，但是整个执行期间过长。</p>
<p>优化点有以下：</p>
<ol>
<li>
<p>（线程池告警）该线程池的任务队列告警阈值需要降低阈值优化，如果是核心业务，则需要减少降低限度（如5%），直至可以在运维发现问题后，有足够时间让开发排查；如果不是核心业务，则可以随便修改，甚至不修改</p>
</li>
<li>
<p>（线程池参数）增加任务队列容量，如果遇到任务激增，则可以尽量避免触发拒绝策略</p>
<p>线程存活时间可以增加（1000~10000之间是业务上比较合理的数值），避免比核心线程数多的对应数量线程</p>
<p>增加核心线程数与最大线程数（如原有数量*2）</p>
</li>
<li>
<p>（其他）单个任务逻辑，优化可以从异步，并发等方面入手</p>
<p>启动时预热全部核心线程数量，避免创建线程导致任务消耗时间增加</p>
<p>增加pod数量</p>
</li>
</ol>
<h2 id="2、有哪些需要的线程池告警">2、有哪些需要的线程池告警</h2>
<p>调参通知、队列容量告警、拒绝策略告警必然是需要的<br>
核心微服务：<br>
必须加上 调参通知、队列容量告警、拒绝策略告警<br>
如果是对于设备时效性要求较高=&gt;加上 任务排队超时告警、任务执行超时告警<br>
如果是长任务=&gt;加上 任务执行超时告警、线程池活跃度告警</p>
<p>非核心为服务：<br>
一般只需要 调参通知、队列容量告警、拒绝策略告警，后续根据业务需要增加</p>
<blockquote>
<p>告警阈值怎么设定？</p>
</blockquote>
<ol>
<li>可以优先按照Dynamic-TP的默认阈值</li>
<li>触发频率可以先按照Dynamic-TP的默认阈值</li>
<li>可以依据部门要求加上其他要求，后续根据线上实践及时修改</li>
<li>如果需要告警触发频率限流则需要开发同事新增代码实现</li>
</ol>
<h2 id="2、线程池告警阈值和线程池参数怎么设置">2、线程池告警阈值和线程池参数怎么设置</h2>
<p>线程池有以下几种形式：</p>
<ol>
<li>线程池为单个spring项目公用、或者是全部服务只有2个线程池，CPU密集型线程池与IO密集型线程池</li>
<li>线程池根据不同业务分为多个线程池，且父线程与子线程在不同线程池中执行</li>
</ol>
<p>推荐使用方式2</p>
<p>优先基于一些理论得到合适一些的线程池参数</p>
<p><img src="https://hexo-1304698044.cos.ap-shanghai.myqcloud.com/blog/image-20250712122633081.png" alt="image-20250712122633081"></p>
<p><strong>核心微服务：</strong></p>
<p>基于计算得到的理论线程池参数根据Jmeter进行压侧微调，直至获得最合适的线程池参数</p>
<p>以上是理论上的线程池参数，为了可以更好地使用线程池，还需要根据压力测试对线程池参数进行微调，直至可以获得能最大限度利用资源的。<br>
压测-压测报告对比-调参-再压测。。。重复循环，直到获取到最优的线程池参数配置。</p>
<p><strong>非核心微服务：</strong></p>
<p>不如直接根据理论值配好上线，如果有压力可以立刻增加资源、修改线程池参数。<br>
可有可无的微服务，要避免浪费资源，也需要线程池监控查看配置，此时线程池情况可以做一个较好的缩容的指标。</p>
<h1>4、触发告警后怎么进行排查</h1>
<p>首先需要明确一下几点：</p>
<ol>
<li>收到告警时，需要先看告警是否配置正常</li>
<li>偶发告警基本上不需要关注，只有遇到持续性告警才需要介入处理</li>
</ol>
<p>排查思路大概如下：</p>
<p><img src="https://hexo-1304698044.cos.ap-shanghai.myqcloud.com/blog/image-20250712122642995.png" alt="image-20250712122642995"></p>
<h1>5、怎么根据业务增长重新修改资源与线程池参数</h1>
<p>需要关注的点：</p>
<ol>
<li>
<p>业务增长怎么转换成可以量化的“需要新增的资源量”</p>
</li>
<li>
<p>业务增长后，可以依据原有微调后的参数等比例修改，后再进行压侧/根据实际业务微调参数<br>
核心微服务可以根据压测修改，非核心业务可以根据CPU核数重新计算。</p>
</li>
<li>
<p>业务增长后，监控项是否需要增减，是否需要改阈值<br>
监控项需要根据业务特性是否发生变更做更改；</p>
</li>
</ol>
<p>阈值由于是一个百分比，可以不变，后续再根据业务预警做修改。</p>
<h2 id="6、推荐阅读">6、推荐阅读</h2>
<ol>
<li><a target="_blank" rel="noopener" href="https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html">Java线程池实现原理及其在美团业务中的实践</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/7197424371991855159">线程数突增！领导说再这么写就gc掉我</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/7322156706723823626">我决定蹭一下“线程数突增…”这篇文章的热度。</a></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/07/12/%E8%AE%BE%E8%AE%A1/3.Dynamic-TP%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="annabergite">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="艾迪的技术之路">
      <meta itemprop="description" content="记录博客与成长,Java，架构">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 艾迪的技术之路">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/07/12/%E8%AE%BE%E8%AE%A1/3.Dynamic-TP%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/" class="post-title-link" itemprop="url">Dynamic-TP底层原理解析</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-07-12 12:14:50 / 修改时间：23:16:11" itemprop="dateCreated datePublished" datetime="2025-07-12T12:14:50+08:00">2025-07-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index"><span itemprop="name">设计</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="前言">前言</h2>
<p>之前我有写过一篇文章，讲述的是怎么使用<code>Dynamic-TP</code> 做一些节省开发的一些问题，但是我感觉不能就直接这么算了，我还想看一下这个框架的一些内部逻辑，避免鸽太久自己以及忘了这回事情或者是还要花比较大的学习成本重新看一下源码，所以我打算花点时间狠狠的看下源码，整理一下自己认为有用的信息，毕竟要知其然更要知其所以然嘛~</p>
<p>我阅读的Dtp源码是1.1.9</p>
<p>之前使用<code>Dynamic-TP</code> 主要是为了使用它的以下功能：</p>
<ol>
<li>动态调参</li>
<li>实时监控</li>
<li>通知告警</li>
<li>告警拓展</li>
<li>框架自带线程池</li>
<li>线程池注册</li>
<li>其他</li>
</ol>
<p>所以我也打算从以下几个方面看下相关的一些源码</p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/27175151/1727972366167-615c36ba-c378-47b2-bd0f-224a3d912e3d.png" alt="img"></p>
<p><img src="C:%5CUsers%5Czhubaiyi%5CDesktop%5CDtp%E6%80%BB%E8%A7%88.png" alt="Dtp总览"></p>
<h2 id="1、动态调参">1、动态调参</h2>
<p>虽然动态调参JDK1.8就自带的，但是实际上的<code>Dynamic-TP</code>动态调参实际上有一定的修改的</p>
<p>据我观察<code>Dynamic-TP</code>使用的是这组代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">doRefresh</span><span class="params">(ExecutorWrapper executorWrapper, DtpExecutorProps props)</span> &#123;</span><br><span class="line">    ExecutorAdapter&lt;?&gt; executor = executorWrapper.getExecutor();</span><br><span class="line">    doRefreshPoolSize(executor, props);</span><br><span class="line">    <span class="keyword">if</span> (!Objects.equals(executor.getKeepAliveTime(props.getUnit()), props.getKeepAliveTime())) &#123;</span><br><span class="line">        executor.setKeepAliveTime(props.getKeepAliveTime(), props.getUnit());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!Objects.equals(executor.allowsCoreThreadTimeOut(), props.isAllowCoreThreadTimeOut())) &#123;</span><br><span class="line">        executor.allowCoreThreadTimeOut(props.isAllowCoreThreadTimeOut());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// update queue</span></span><br><span class="line">    updateQueueProps(executor, props);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (executorWrapper.isDtpExecutor()) &#123;</span><br><span class="line">        doRefreshDtp(executorWrapper, props);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    doRefreshCommon(executorWrapper, props);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><code>doRefreshPoolSize()</code>方法是修改核心线程数和最大线程数，期间涉及到核心线程是是要不如最大线程数大的，不然会报问题，最终调用JDK的修改参数的方法（不过实际上ThreadPoolExecutor本身就是支持校验核心线程数和最大线程数之间比较的）</li>
<li><code>Objects.equals(executor.getKeepAliveTime(props.getUnit()), props.getKeepAliveTime()))</code>是由于配置文件里面默认是TimeUnit是秒，所以此处的比较还是根据秒做比较，当然<code>Dynamic-TP</code>自己有自己的线程池</li>
</ol>
<p>由于是修改的非核心线程的最大保活信息，底层修改的时候，会使用LockSupport、CAS方式关掉线程池(JBoss)，或者是通过ReentrantLock遍历关闭对应超过最大时间的线程(Tomcat)</p>
<ol>
<li>
<p>修改queue的时候，如果是内存安全线程则会修改最大使用内存，如果不相等才会修改任务队列；此外会修改 [OrderedDtpExecutor] 的信息</p>
</li>
<li>
<p>方法<code>doRefreshCommon</code>修改了拒绝策略等信息，并且如果有配置事件</p>
</li>
<li>
<p>AbstractDtpAdapter类监听了配置更新的事件，只有配置更新的时候才会调用以上的方法。出发方式的话，如果是nacos的话，则会通过某种方式实现的发布事件让Java程序监听。</p>
<p>该方式在CloudNacosRefresher中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(<span class="meta">@NonNull</span> ApplicationEvent event)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (needRefresh(((EnvironmentChangeEvent) event).getKeys())) &#123;</span><br><span class="line">        refresh(environment);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="2、实时监控">2、实时监控</h2>
<p>实时监控是通过DtpMonitor类实现的，此处实际上就是通过Spring的事件机制进行事件监控与触发。DtpMonitor自带一个定时任务线程池，最大线程数只有一个。DtpMonitor继承了OnceApplicationContextEventListener抽象类，这个类实现了以下方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(ApplicationEvent event)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (isOriginalEventSource(event) &amp;&amp; event <span class="keyword">instanceof</span> ApplicationContextEvent) &#123;</span><br><span class="line">    <span class="keyword">if</span> (event <span class="keyword">instanceof</span> ContextRefreshedEvent) &#123;</span><br><span class="line">        onContextRefreshedEvent((ContextRefreshedEvent) event);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event <span class="keyword">instanceof</span> ContextStartedEvent) &#123;</span><br><span class="line">        onContextStartedEvent((ContextStartedEvent) event);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event <span class="keyword">instanceof</span> ContextStoppedEvent) &#123;</span><br><span class="line">        onContextStoppedEvent((ContextStoppedEvent) event);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event <span class="keyword">instanceof</span> ContextClosedEvent) &#123;</span><br><span class="line">        onContextClosedEvent((ContextClosedEvent) event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>onContextRefreshedEvent、onContextStartedEvent、onContextStoppedEvent、onContextClosedEvent是Dynamic-TP需要的事件，不过DtpMonitor只实现了onContextRefreshedEvent方法</p>
<ol>
<li>onContextRefreshedEvent会起一个0秒后启动的定时任务，这个任务会给全部的注册在DtpRegistry的线程池发告警消息，AlarmManager会使用自己对象中的线程池ALARM_EXECUTOR进行发布告警消息，告警消息我看只有查看线程活度和任务队列容量，遍历进行告警。</li>
<li>此处使用了spring的事件机制，这个使用来说就是现在存在事件和事件监听器，只要逐注册一个事件监听器，实现 <code>ApplicationListener</code>接口，接口泛型是 你想监听的类。</li>
</ol>
<p>只要ApplicationContext发布一个你想监听的类的对象，对应想监听这个类的监听器就能监听到，做对应的事情，不过范围只是Java程序内的，做不到分布式的。Dynamic-tp中OnceApplicationContextEventListener就是我们需要监听的事件</p>
<ol>
<li>言归正传，实际上就是起一个任务分别发布告警和监控的事件</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    Set&lt;String&gt; executorNames = DtpRegistry.getAllExecutorNames();</span><br><span class="line">    checkAlarm(executorNames);</span><br><span class="line">    collectMetrics(executorNames);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">checkAlarm</span><span class="params">(Set&lt;String&gt; executorNames)</span> &#123;</span><br><span class="line">    executorNames.forEach(name -&gt; &#123;</span><br><span class="line">        <span class="type">ExecutorWrapper</span> <span class="variable">wrapper</span> <span class="operator">=</span> DtpRegistry.getExecutorWrapper(name);</span><br><span class="line">        AlarmManager.tryAlarmAsync(wrapper, SCHEDULE_NOTIFY_ITEMS);</span><br><span class="line">    &#125;);</span><br><span class="line">    publishAlarmCheckEvent();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">collectMetrics</span><span class="params">(Set&lt;String&gt; executorNames)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!dtpProperties.isEnabledCollect()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    executorNames.forEach(x -&gt; &#123;</span><br><span class="line">        <span class="type">ExecutorWrapper</span> <span class="variable">wrapper</span> <span class="operator">=</span> DtpRegistry.getExecutorWrapper(x);</span><br><span class="line">        doCollect(ExecutorConverter.toMetrics(wrapper));</span><br><span class="line">    &#125;);</span><br><span class="line">    publishCollectEvent();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>我们分别查看，发出的监控和告警都会到达DtpAdapterListener类，该类会在以下方法中监听对应事件</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(<span class="meta">@NonNull</span> ApplicationEvent event)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (event <span class="keyword">instanceof</span> RefreshEvent) &#123;</span><br><span class="line">            doRefresh(((RefreshEvent) event).getDtpProperties());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event <span class="keyword">instanceof</span> CollectEvent) &#123;</span><br><span class="line">            doCollect(((CollectEvent) event).getDtpProperties());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event <span class="keyword">instanceof</span> AlarmCheckEvent) &#123;</span><br><span class="line">            doAlarmCheck(((AlarmCheckEvent) event).getDtpProperties());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;DynamicTp adapter, event handle failed.&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>处理时会先看是否有DtpAdapter的实现类对于对应的线程池，发送对应的告警，注意DtpAdapter只会对告警做发送，筛选什么的还是在alarm模块里面做。</p>
<p>数据采集会有一个专门的类CollectorHandler用于处理数据采集，这个数据采集也是调用一个类，遍历collectorTypeList的时候调用该方法，会有具体实现类进行实现的。</p>
<h2 id="怎么进行告警的？">怎么进行告警的？</h2>
<p>通过eventBus（虽然据说是做出来给Android用的，发布者需要使用post()，然后需要一个接收的，通过使用@subscirbe进行event类型的获取，怎么看是否是拿到了合适的，需要通过实现applicationevent后，接受提需要入参是对应类型的event类才能拿到，这种方法一般是void方法）</p>
<p>dynamic-tp中自定义event是这么写的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomContextRefreshedEvent</span> <span class="keyword">extends</span> <span class="title class_">EventObject</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CustomContextRefreshedEvent</span><span class="params">(Object source)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(source);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在dtpMonitor中，会获取刷新配置的时间，通过这种方式（我才创建的时候会在lifecycle里面先创建时间与事件监听，再发布一个刷新配置的事件）会DtpMonitor中创建一个定时任务，这个定时任务会发布一个AlarmCheckEvent的事件</p>
<p><img src="C:%5CUsers%5Czhubaiyi%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20241117155135973.png" alt="image-20241117155135973"></p>
<p>此处会发现它指向了这个context -&gt;相关的代码段，在这个代码段中，会获取全部的dtpadpter（因为第三方组件也会可能使用dtp组件），获取全部dtpadpter的全部线程池wrapper（通常存放着线程池的信息以及一些通知平台和告警项），接着会对全部线程池wrapper查看liveness和capacity，如果到了时间且出发了liveness和capacity，则会进行通知告警，走通知告警的逻辑。</p>
<p>liveness的判断逻辑就是单纯的除法</p>
<h2 id="3、通知告警">3、通知告警</h2>
<p>告警主要是看AbstractNotifier、AlarmManager这两个Java类。</p>
<ol>
<li>AbstractNotifier用于处理发送功能，该方式解决了通过send()方法实现发送调参通知、发送告警通知、创建告警内容、创建通知内容、通过MDC获取trace信息、配置receiver的信息（发送调参通知、发送告警通知会使用）、高亮、获取Const类里面的文本信息。</li>
</ol>
<p>AbstractNotifier类本身是继承了DtpNotifier，DtpNotifier只存储平台信息、发送告警信息、发送变更信息。其他通知类的具体实现类则是实现了send方法，当然也可以实现其他方法。</p>
<ol>
<li>AlarmManager类里面给IOC容器注册了一个线程池，最大线程数量就1个，任务队列数量是2000个、NoticeManager则是创建了一个任务队列是100个的线程池，一开始创建该类时候会分别执行一次static方法块中的方法，为的是创建过滤器查看哪些平台需要通知。我们以AlarmManager为主要学习类。</li>
</ol>
<p>值得学习的事情是，遍历该告警那些平台选择过滤条件的时候是从末往前遍历，在更细化一层的时候拿到的信息如果没有的话，会优先使用上一层的信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SafeVarargs</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; InvokerChain&lt;T&gt; <span class="title function_">buildInvokerChain</span><span class="params">(Invoker&lt;T&gt; target, Filter&lt;T&gt;... filters)</span> &#123;</span><br><span class="line"></span><br><span class="line">    InvokerChain&lt;T&gt; invokerChain = <span class="keyword">new</span> <span class="title class_">InvokerChain</span>&lt;&gt;();</span><br><span class="line">    Invoker&lt;T&gt; last = target;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> filters.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        Invoker&lt;T&gt; next = last;</span><br><span class="line">        Filter&lt;T&gt; filter = filters[i];</span><br><span class="line">        last = context -&gt; filter.doFilter(context, next);</span><br><span class="line">    &#125;</span><br><span class="line">    invokerChain.setHead(last);</span><br><span class="line">    <span class="keyword">return</span> invokerChain;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>是在<code>InvokerChainFactory</code>类中做的过滤，常见的过滤方式存储在AlarmBaseFilter/NoticeBaseFilter/NotifyRedisRateLimiterFilter中，我们当前只看AlarmBaseFilter。</p>
<p>AlarmBaseFilter做过滤操作的时候，会需要ALarm的上下文信息(AlarmCtx，就是存储通知信息以及哪个线程池需要做通知)、Alarm的触发器(AlarmInvoker会配置对应的上下文信息，发送对应alarm信息，重置告警的触发条件，告警信息存储在ConcurrentHashMap，是线程安全的。AlarmCounter)，</p>
<p>一开始就会调用invoke方法？</p>
<p>本身是实现了一个链表的invoke的实现，最终创建了一个invokeChain</p>
<p>这句话可能会去掉。配置文件DtpBaseBeanConfiguration会创建一个DtpLifecycle，DtpLifecycle会从注册器中取的全部的注册在DTPRegistry中executor的对象进行初始化（此处会使用CAS保证线程安全），每个DTP线程池遍历使用DtpLifecycleSupport初始化该线程池ExecutorWrapper，ExecutorWrapper初始化的时候不仅会初始化AwareManger，也会初始化线程池对象，线程池对象初始化会优先使用NotifyHelper初始化自己的通知系统，获取DtpProperties和通知平台信息。因为通过哪个平台通知和触发什么情况的时候通知是解耦的，所以只有 触发解耦的条件 会被用来遍历告警频率限制初始化、告警计数器初始化，这两个对象都会存储一个ConcurrentHashMap。</p>
<ol>
<li>NotifierHandler和AlarmInvoker、NoticeInvoker相关，NotifierHandler在初始化的时候会默认使用ExtensionServiceLoader获取全部的DtpNotifier的对象，存储在HashMap中</li>
</ol>
<p>NotifierHandler也会写sendNotice、sendAlarm，这就将其和AlarmInvoker、NoticeInvoker联系起来了。</p>
<p>具体的告警如下所示：</p>
<ol>
<li>有些告警是通过定时任务去触发的，Dtp使用的是Timer时间轮做的效果，通过使用HashedWheelTimer.run()方法进行查看，如<strong>活跃度、队列容量</strong>告警都是适用的这个方式</li>
<li><strong>拒绝策略告警</strong>出发是AwareManager通过<strong>beforeReject</strong>方法让AlarmManager进行通知。DtpExecutor线程池用到的RejectedExecutionHandler是经过动态代理包装过的</li>
<li><strong>任务队列超时告警、任务执行超时告警</strong>官网上说是通过重写重写ThreadPoolExecutor的execute()方法和beforeExecute()方法实现的。当然现在新版本代码是通过Timer时间轮实现的，在AlarmManager中统一进行查看修改。并且Dtp线程池在创建线程等操作的时候会通过AwareManager主动开启一个任务</li>
</ol>
<h6 id="高亮是怎么实现的？">高亮是怎么实现的？</h6>
<p>如告警过程中，通过buildAlarmContent方法创建内容时候，会执行高亮API</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> String <span class="title function_">highlightAlarmContent</span><span class="params">(String content, NotifyItemEnum notifyItemEnum)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(content) || Objects.isNull(getColors())) &#123;</span><br><span class="line">            <span class="keyword">return</span> content;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Set&lt;String&gt; colorKeys = getAlarmKeys(notifyItemEnum);</span><br><span class="line">        Pair&lt;String, String&gt; pair = getColors();</span><br><span class="line">        <span class="keyword">for</span> (String field : colorKeys) &#123;</span><br><span class="line">            content = content.replace(field, pair.getLeft());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (String field : getAllAlarmKeys()) &#123;</span><br><span class="line">            content = content.replace(field, pair.getRight());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> content;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>会将获取需要高亮的信息（存储在NotifyItemEnum中），进行颜色替换</p>
<h2 id="4、告警拓展">4、告警拓展</h2>
<ol>
<li>告警拓展具体来讲就是自己写了个新告警，但是新告警需要使用JDK SPI机制，JDK SPI是因为我们传输的Alarm信息不能被IOC容器管理，因为我们是一个告警需要产生一个类的，Spring SPI靠的是将JDK SPI的类加载IOC容器中实现的可加载模式的。</li>
<li>为什么是使用JDK SPI？因为使用Spring SPI是需要托管到IOC容器的，但是NotifierHandler本身会处理告警通知，但是如果如果要做到动态修改配置与个数，则需要做到实时的创建与删除，变成Bean是不够合理的，所以才会使用JDK SPI方式，通过以下方式实现</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">invoke</span><span class="params">(BaseNotifyCtx context)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            DtpNotifyCtxHolder.set(context);</span><br><span class="line">            <span class="type">val</span> <span class="variable">noticeCtx</span> <span class="operator">=</span> (NoticeCtx) context;</span><br><span class="line">            NotifierHandler.getInstance().sendNotice(noticeCtx.getOldFields(), noticeCtx.getDiffs());</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            DtpNotifyCtxHolder.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> NotifierHandler <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> NotifierHandlerHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">NotifierHandlerHolder</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">NotifierHandler</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NotifierHandler</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">NotifierHandler</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;DtpNotifier&gt; loadedNotifiers = ExtensionServiceLoader.get(DtpNotifier.class);</span><br><span class="line">        loadedNotifiers.forEach(notifier -&gt; NOTIFIERS.put(notifier.platform(), notifier));</span><br><span class="line"></span><br><span class="line">        <span class="type">DtpNotifier</span> <span class="variable">dingNotifier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DtpDingNotifier</span>(<span class="keyword">new</span> <span class="title class_">DingNotifier</span>());</span><br><span class="line">        <span class="type">DtpNotifier</span> <span class="variable">wechatNotifier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DtpWechatNotifier</span>(<span class="keyword">new</span> <span class="title class_">WechatNotifier</span>());</span><br><span class="line">        <span class="type">DtpNotifier</span> <span class="variable">larkNotifier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DtpLarkNotifier</span>(<span class="keyword">new</span> <span class="title class_">LarkNotifier</span>());</span><br><span class="line">        NOTIFIERS.put(dingNotifier.platform(), dingNotifier);</span><br><span class="line">        NOTIFIERS.put(wechatNotifier.platform(), wechatNotifier);</span><br><span class="line">        NOTIFIERS.put(larkNotifier.platform(), larkNotifier);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到实际上是通过创建一个NotifierHandler进行通知，每次创建都会通过获取通过任何方式提供的DtpNotifier服务，后将其注册到这个创建的NotifierHandler的Map中。</p>
<h2 id="5、框架自带线程池">5、框架自带线程池</h2>
<p>框架自带线程池均继承自<code>DtpExecutor</code>,<code>DtpExecutor</code>继承自<code>ThreadPoolExecutor</code>，顺便实现了SpringExecutor, TaskEnhanceAware, ExecutorAdapter<ThreadPoolExecutor>，具体原理是在<strong>execute</strong>、<strong>beforeExecute</strong>、<strong>afterExecute</strong>上面做了增强，包装成了DtpExecutor自己的</p>
<p>源码中，除了Tomcat第三方线程池有不同外，其他的都是如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void beforeExecute(Thread t, Runnable r) &#123;</span><br><span class="line">    super.beforeExecute(t, r);</span><br><span class="line">    AwareManager.beforeExecute(this, t, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到是总是会先调用ThreadPoolExecutor的beforeExecute方法，然后会使用AwareManager.beforeExecute()方法，这个方法会先删除掉原先的Runnable，然后在开启一个新的Runnable，因为要设置线程的期限运行时间，所以会使用Timer时间轮做定时关掉的任务</p>
<p>执行execute方法时候，则必定会调用AwareManager.execute方法，只有被DynamicTp增强后的任务才会被DTP自己加载监控等信息，然后再开启任务。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void afterExecute(Executor executor, Runnable r, Throwable t) &#123;</span><br><span class="line">    Optional.ofNullable(statProviders.get(executor)).ifPresent(p -&gt; p.completeTask(r));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见也是先调用ThreadPoolExecutor的afterExecute方法，再看对应Executor是否存储在DTP里面，有的话再调用该Executor删除掉对应任务。</p>
<h2 id="6、线程池注册">6、线程池注册</h2>
<p>虽然看起来线程池注册是在整个框架中比较不常见的，但是这个也非常的重要，值得我们学习与阅读。DtpRegistry也继承了OnceApplicationContextEventListener，这代表</p>
<ol>
<li>
<p>线程池注册在DtpRegistry里面，里面的话是一个ConcurrentHashMap</p>
<p>public class DtpPostProcessor implements BeanPostProcessor, BeanFactoryAware, PriorityOrdered</p>
<p>b. 另外就是会将获取DtpRegistry中线程池的一些操作API给放这个类里面了；监听事件刷线配置的操作也存放在这个类里面了。这个刷新方法会同时刷新Dtp线程池和不是Dtp但是托管给了Dtp的线程池。</p>
</li>
</ol>
<h2 id="7、其他">7、其他</h2>
<h3 id="7-1、对接第三方线程池">7.1、对接第三方线程池</h3>
<p>adapter模块目前已经接入了SpringBoot内置的三大WebServer（Tomcat、Jetty、Undertow）的线程池管理，实现层面也是和核心模块做了解耦，利用spring的事件机制进行通知监听处理。通过initialize()方法拿到webServer的线程池</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initialize</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.initialize();</span><br><span class="line">    <span class="keyword">if</span> (executors.get(getTpName()) == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> ApplicationContextHolder.getInstance();</span><br><span class="line">        <span class="type">WebServer</span> <span class="variable">webServer</span> <span class="operator">=</span> ((WebServerApplicationContext) applicationContext).getWebServer();</span><br><span class="line">        doEnhance(webServer);</span><br><span class="line">        log.info(<span class="string">&quot;DynamicTp adapter, web server &#123;&#125; executor init end, executor: &#123;&#125;&quot;</span>,</span><br><span class="line">                getTpName(), ExecutorConverter.toMainFields(executors.get(getTpName())));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个方法中，doEnhance()方法会修改WebServer的线程池为Dtp自己的线程池，且该线程池会受到对应webserver线程池参数的影响</p>
<p>其他的则和我们在项目中使用的Dtp线程池具体代码实现相差无几</p>
<h3 id="7-2、Dynamic-TP对于Spring的使用">7.2、Dynamic-TP对于Spring的使用</h3>
<h5 id="DtpPostProcessor">DtpPostProcessor</h5>
<p>具体来讲这个类就是在单例化Bean的时候，如果发现不是ThreadPoolTaskExecutor、ThreadPoolExecutor就不做操作，如果是DtpExecutor或者是ThreadPoolTaskExecutor、ThreadPoolExecutor就做一组操作进行包装。</p>
<p>@1:如果bean不是ThreadPoolExecutor或者ThreadPoolTaskExecutor，那么就不对bean做任何处理，直接返回</p>
<p>@2:如果bean是DtpExecutor,调用registerDtp方法填充DTP_REGISTRY这个map</p>
<p>@3:如果说bean上面的DynamicTp注解，使用注解的值作为线程池的名称，没有的话就使用bean的名称</p>
<p>@4:如果bean是spring中的ThreadPoolTaskExecutor的话，那么就通过getThreadPoolExecutor()方法拿到ThreadPoolExecutor注册到COMMON_REGISTRY中</p>
<p>到这里执行完，就针对所有线程池对象完成了增强</p>
<p>看起来复杂实际上简单</p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/27175151/1727972390194-b8108b67-28ee-4f22-b6fb-094e762fc544.png" alt="img"></p>
<h6 id="AwareManager">AwareManager</h6>
<ol>
<li>这个其实是相当重要的一块，涉及到了以关闭线程池、终止线程池、执行一个任务、注册、添加、更新线程池、拒绝策略为切面实现了一组操作</li>
<li>涉及到监控、触发拒绝等问题，因为线程池是实时在变化的，参数调整、任务的创建和完成等操作，都会涉及到监控指标，拒绝策略的修改，因此为了更好地使用资源，所以才会有AwareManager。</li>
</ol>
<h6 id="DtpInterceptorRegistry">DtpInterceptorRegistry</h6>
<p>根据注解@DtpInterceptor获取对应拦截器信息，基于此提供了对应的API</p>
<h6 id="DtpInterceptorProxyFactory">DtpInterceptorProxyFactory</h6>
<p>存储着一些动态代理的方法，如getSignatureMap获取注解的信息修改</p>
<h1>总结</h1>
<p>笔者看了下美团的动态线程池实践，发现了JDK8的线程池的内部维护的逻辑，看起来还是很不错的</p>
<p>内部有个worker，这个worker里面有thread和runnable，所以既有任务又有线程去维护，本身线程池是 内部有很多信息 的</p>
<p>线程池本身有五种状态，其他四种是为了结束线程池而特意准备的</p>
<p>线程有线程状态和线程数量 这俩状态，在高并发的情况下，使用两个变量去存储则会比较麻烦，不如使用一个AotmicInteger，高三位存储线程池中线程状态，低26位存储线程数量。</p>
<p>也有worker的回收线程。</p>
<p>线程池怎么使用，最好还是按照不同业务来分配线程池，避免不同任务之间有父子级关系，导致OOM，也有可能会因为一部分业务占用资源过多导致出现其他业务饥饿的现象</p>
<p>dynamic-tp本身使用了eventBus，我个人觉得很不错。通过使用@subscribe注解实现的，这个注解有些属性，ThreadMode 线程模式，主要是看发布者和订阅者执行的一个方式，posting就是一个发送事件谁执行事件的一种方式。sticky属性类似于广播中的粘性广播。可以先将事件发出，留存在内存中，后面等到有订阅方法时，再接受订阅。priority 优先级可以使得优先级更高的获取到对应信息。</p>
<p>线程池有submit和execute这两者的区别在于execute只能提交Runnable类型的任务；submit既能提交Runnable类型任务也能提交Callable类型任务。</p>
<ul>
<li>execute会直接报错，需要trycatch，和普通执行任务一样；但是submit会吞掉异常只能通过future.get()拿到对应信息。</li>
<li>execute没有返回值，submit有返回值。</li>
<li>如果提交任务不需要结果的话则不需要使用submit，execute更快</li>
</ul>
<h2 id="引用文章">引用文章</h2>
<ol>
<li><a target="_blank" rel="noopener" href="https://dynamictp.cn/">dynamictp官网</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/7069581808932749348">动态线程池框架（DynamicTp），监控及源码解析篇</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_46119575/article/details/129740247">SpringBoot：Bean生命周期介绍</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_52897007/article/details/140507980">Spring Bean的生命周期</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qusikao/article/details/136546149">Spring揭秘：ApplicationContextAware应用场景及实现原理！</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/jike11231/article/details/124872298">观察者模式Spring之publishEvent事件处理</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_36268103/article/details/136237301">Java 创建事件(Event)、事件监听器(EventListener)、事件发布(publishEvent)详解和相关demo</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/u011047968/article/details/106730822">java中的“&amp;”、“|”、“^”、“~”运算符怎么用？</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/7114911821944864775">基于开源的配置中心的轻量动态线程池dynamic-tp实践与源码原理分析</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/swadian2008/article/details/100173207">Java 中的定时器类Timer详解</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/7380545407728959515">SoftReference 到底在什么时候被回收 ？ 如何量化内存不足 ？</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_46085118/article/details/127965728">com.google.common.base.Joiner，谷歌提供的字符串处理工具</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/6917869425634852878">applicationContext.getBeansOfType(class)获取某一接口的所有实现类，应用于策略模式简单demo | 掘金</a></li>
<li><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/2379546">玩转Spring生命周期之Lifecycle和SmartLifecycle</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/moshowgame/article/details/140254380">SpringBoot的SmartLifecycle生命周期接口</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qyhua/article/details/135127957">java 非常好用的一个缓存（Google Guava的Cache）</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_24654501/category_11384283.html">https://blog.csdn.net/qq_24654501/category_11384283.html</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/x123453316/article/details/120684497">ApplicationEvent 的简介及简单使用</a></li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/tm5p9fwLqmly0jWwiyzRJQ">动态线程池DynamicTp系列四之监控告警</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/7393190128547610662">SpringBoot实现静态、动态定时任务，本地动态定时任务调度</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/6989223598577680421">Google Java编程风格规范(2020年4月原版翻译)</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_26664043/article/details/135862192">提升编程效率的利器: 解析Google Guava库之集合篇Immutable（一）</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/7359118871981228084">事件驱动模型的最佳实践-SpringEvent【（二）原理篇】</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/7398352986324434970">【Spring Boot 源码学习】ConditionEvaluationReport 日志记录上下文初始化器</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_39099625/article/details/">SpringBoot-5.ApplicationListener子接口GenericApplicationListener, SmartApplicationListener</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/blogslee/p/10855829.html">谷歌工具导包-com.google.common.collect</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_33068055/article/details/141749160">Google Collections：Java开发者必备的集合处理库Guava教程</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/tianjindong0804/article/details/124907900">一文读懂Spring的SPI机制</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/huahua035/p/11272464.html">SpringBoot加载自定义yml文件</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_59690068/article/details/135686750">org.apache.commons.collections4下的CollectionUtils工具类</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/7295554616951308315?searchId=20241003231157B030E9821F1424F06E71">Java工具库——commons-lang3的50个常用方法）集合开发工具大利器</a></li>
<li><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1664236">Spring Aware机制</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/7397676488294203428">那些年背过的题目：Spring ApplicationContext- IOC容器初始化过程</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/7308610896803659812?searchId=202410032318244162CFB78E9122DE54E4">一张长图透彻理解SpringBoot 启动原理，架构师必备知识，不为应付面试！</a></li>
<li><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1817143">beandefinition与beanfactory</a></li>
<li><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/2149803">面试篇之什么是静态代理？什么是动态代理？</a></li>
<li><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1008496">Spring IOC容器分析(3) – DefaultListableBeanFactory</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/mindfloating/article/details/8033340">Timing Wheel 定时轮算法</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/7017276275655966727">Java开发利器Commons Lang之元组</a></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/07/12/%E5%BC%80%E5%8F%91/10.%E6%85%A2SQL%E4%BC%98%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="annabergite">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="艾迪的技术之路">
      <meta itemprop="description" content="记录博客与成长,Java，架构">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 艾迪的技术之路">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/07/12/%E5%BC%80%E5%8F%91/10.%E6%85%A2SQL%E4%BC%98%E5%8C%96/" class="post-title-link" itemprop="url">线上慢查询优化</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-07-12 12:14:50" itemprop="dateCreated datePublished" datetime="2025-07-12T12:14:50+08:00">2025-07-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-07-21 23:51:00" itemprop="dateModified" datetime="2025-07-21T23:51:00+08:00">2025-07-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">开发</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">问题处理</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1>1、背景</h1>
<p>告警页面由APP+ H5开发转纯H5页面优化</p>
<p>好处</p>
<ol>
<li>开发与维护需要服务端+APP+H5同时开发，对于项目管理复杂</li>
<li>转成H5可以减少APP的开发压力</li>
</ol>
<h2 id="1-1、问题现象">1.1、问题现象</h2>
<ol>
<li>
<p>慢查询16K/天</p>
<p><img src="https://hexo-1304698044.cos.ap-shanghai.myqcloud.com/blog/2e714778e23510985c77506bd312df31.png" alt="2e714778e23510985c77506bd312df31"></p>
</li>
<li>
<p>线上MySQL CPU有激增现象，不过缓存命中率，内存利用率无明显变化</p>
<p><img src="https://hexo-1304698044.cos.ap-shanghai.myqcloud.com/blog/dad9dd59dcd8a89c4f7740769393f056.png" alt="dad9dd59dcd8a89c4f7740769393f056"></p>
<p><img src="https://hexo-1304698044.cos.ap-shanghai.myqcloud.com/blog/bdb64a65f6f6b66224f0433610086d82.png" alt="bdb64a65f6f6b66224f0433610086d82"></p>
</li>
</ol>
<h1>2、排查方式</h1>
<p>结论先行，以下是该列表的优化流程</p>
<pre class="mermaid">flowchart 
    A[有先查看MySQL优化建议,依据智能优化作为基础优化方式] -->B(分析慢查询与CPU关系,发现解决慢查询即可优化CPU问题)
    B --> C[分析慢查询统计,排查该优化哪个慢查询sql,对应到Java代码]
    C --> D[explain分析具体优化点]</pre>
<ol>
<li>
<p>直接使用购买MySQL实例的腾讯云上面的智能优化</p>
<p><strong>可以优先查看AI的优化建议进行快速修复的凭证</strong></p>
<p><img src="https://hexo-1304698044.cos.ap-shanghai.myqcloud.com/blog/87a79fd8faf9089e282428144daccbfe.png" alt="87a79fd8faf9089e282428144daccbfe"></p>
</li>
<li>
<p>查看慢sql的统计情况，发现慢sql和CPU趋势较为相同</p>
<p><strong>这说明如果优化了慢查询，则MysqlCPU较高问题也可以解决</strong></p>
<p><img src="https://hexo-1304698044.cos.ap-shanghai.myqcloud.com/blog/994a8ff4419f284e41339ad008f0d530.png" alt="994a8ff4419f284e41339ad008f0d530"></p>
</li>
<li>
<p>导出慢查询日志，进行sql统计分析，发现其中99%以上是开发的告警信息列表查询语句</p>
<p><strong>这表明优化单一告警即可优化Mysql的慢查询</strong></p>
</li>
<li>
<p>在线上环境使用explain对查询语句进行查看，发现以下现象：</p>
<p>partition占用较多——打算减少partition</p>
<p>type为range，不是ref、eq_ref、const、system等——怀疑索引效果差，需要优化索引</p>
<p>key有值——有索引</p>
<p>rows大，且filtered较小，只有2%——扫描200条数据需要进而扫描大量条数数据，不合理，需修改查询条件</p>
<p>extra——有Using filesort，排序未触发索引，需优化索引</p>
<p><img src="https://hexo-1304698044.cos.ap-shanghai.myqcloud.com/blog/4873f5fb0e88d3f8c86bf327d2fd566e.png" alt="4873f5fb0e88d3f8c86bf327d2fd566e"></p>
</li>
<li>
<p>随机查看其他用户，发现告警量大的用户稳定出现慢查询，告警总量大约是20W-50W，告警量少的用户，即使是跨分区也不会出现慢查询</p>
</li>
</ol>
<h1>3、解决方式</h1>
<h2 id="3-1、自己可以修改的"><strong>3.1、自己可以修改的</strong></h2>
<ol>
<li>
<p>改变查询条件顺序，减少查询条件</p>
<p>expire_time &gt;now()——删除，因为每天会将超过过期时间的数据删掉</p>
<p>alarm_time between and——需要放在最后，因为联合索引在&gt;,&lt;,between and后会失效</p>
<p>设备id ——放到稍微靠前的位置，因为该字段在线上验证时，发现该字段独立度更高，如id 是114514时占总数据的1-5%，而告警类型2000可以占10%左右，所以设备id需要放在比告警类型更靠前的位置</p>
</li>
<li>
<p>优化联合索引顺序，个数</p>
<p>app的最常见查询条件作为联合索引的个数与顺序</p>
<p>通过腾讯云迁移数据到测试环境数据库验证解决</p>
<p>迁移单个表，单表200w数据，去其中的告警量50w单个用户进行压力测试</p>
</li>
<li>
<p>尝试增加资源——MySQL实例已经是购买的最贵的实例，无法优化</p>
</li>
<li>
<p>paritition删除——删除会导致线上长时间停顿20min以上，且涉及到删除过期数据逻辑，无法优化</p>
</li>
</ol>
<h2 id="3-2、需要配合的">3.2、需要配合的</h2>
<h3 id="产品经理">产品经理</h3>
<ol>
<li>重构时默认查询7天，涉及多个partition，可不可以改成默认查询1天——为了在功能上对标海康，大华，不能进行修改</li>
</ol>
<h3 id="app">app</h3>
<ol>
<li>缺少偏移量，期望入参增加偏移量，避免后续出现的深分页问题——app暂时没人力投入，不进行修改</li>
</ol>
<h1>4、问题回溯</h1>
<ol>
<li>
<p>新问题单开发同事开发时直接在原有查询中间添加查询条件</p>
</li>
<li>
<p>以下为测试环境压力测试时CPU，内存图片，无问题</p>
<p>推测可能是因为测试环境压测数据量不够导致问题</p>
<p>为什么没有准备合适数据，原因为慢查询多为数据量较少用户</p>
<p><img src="https://hexo-1304698044.cos.ap-shanghai.myqcloud.com/blog/22b3ee0971451c532addaba0d71b9b62.png" alt="22b3ee0971451c532addaba0d71b9b62"></p>
<p><img src="https://hexo-1304698044.cos.ap-shanghai.myqcloud.com/blog/80f718900c5797ba180e97d6b72d6f36.png" alt="80f718900c5797ba180e97d6b72d6f36"></p>
</li>
</ol>
<h1>5、优化效果</h1>
<ol>
<li>
<p>慢查询explain优化</p>
<p>filtered查询行数降低，筛选率变高</p>
<p>extra没有using filesort</p>
<p>type虽然还是range，但是实际上速度已经可以来到200ms左右，顾先不优化，因为本次目的是减少慢查询降低MySQL压力</p>
<p><img src="https://hexo-1304698044.cos.ap-shanghai.myqcloud.com/blog/image-20250706185239859.png" alt="image-20250706185239859"></p>
</li>
<li>
<p>每日慢查询数量降低，从16k/天 -&gt; 500/天</p>
<p><img src="https://hexo-1304698044.cos.ap-shanghai.myqcloud.com/blog/b658a861b656ca8040d7f77e3f480cc7.png" alt="b658a861b656ca8040d7f77e3f480cc7"></p>
</li>
</ol>
<h1>6、后续优化</h1>
<ol>
<li>APP侧辅助修改提问题单</li>
<li>后续排查发现告警有子模块呼叫查询，也会使用tbl_alarm表，为了减少单表压力，提单将对应查询优化到专门存储呼叫的表中进行查询</li>
</ol>
<h1>7、推荐阅读</h1>
<ol>
<li><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/">Mysql Documentation</a></li>
<li><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html">MySQL documentation explain</a></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/07/12/%E5%BC%80%E5%8F%91/4.Java%E5%BE%AA%E7%8E%AF%E6%93%8D%E4%BD%9C%E5%93%AA%E4%B8%AA%E5%BF%AB%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="annabergite">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="艾迪的技术之路">
      <meta itemprop="description" content="记录博客与成长,Java，架构">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 艾迪的技术之路">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/07/12/%E5%BC%80%E5%8F%91/4.Java%E5%BE%AA%E7%8E%AF%E6%93%8D%E4%BD%9C%E5%93%AA%E4%B8%AA%E5%BF%AB%EF%BC%9F/" class="post-title-link" itemprop="url">spring中的async、schedule的线程问题</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-07-12 12:07:41 / 修改时间：23:16:11" itemprop="dateCreated datePublished" datetime="2025-07-12T12:07:41+08:00">2025-07-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">开发</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1>Java循环操作哪个快？</h1>
<p>2024年10月2日</p>
<p>开发的时候我发现个问题，就是在学习玩streamAPI和lambda表达式后，我就变得越来越喜欢直接使用streamAPI，而不是使用for循环这种方式了，但是这种方式也有一定的缺点，但是直到某一次代码review，我的同事点醒了我，“小火汁，你的stream流写的是挺好，但是问题是为什么从同一个源取相似的对象，要分别写两次stream，你不觉得有点多余了吗？程序员不只是写代码，反而是最初的设计阶段就要把全局流程想好，要避免再犯这种错误哦~”，这句话点醒了我，所以我打算先看一下stream遍历、for循环、增强for循环、迭代器遍历、并行流parallel stream遍历的时间消耗，查看一下这几种方式的异同。</p>
<h2 id="使用stream主要是在做什么？">使用stream主要是在做什么？</h2>
<p>此时我们先准备一个类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Accessors(chain = true)</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Item</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>
<p>list转成map</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.stream().collect(Collectors.toMap(Item::getName, Item::getValue, (newValue, oldValue) -&gt; newValue))</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>List过滤，返回新List</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Item&gt; collect = list.stream().filter(x -&gt; x.getValue() &gt; <span class="number">50</span>).collect(Collectors.toList());</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>模拟多次stream，因为我在开发中经常出现这种问题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, Integer&gt; collect = list.stream().collect(Collectors.toMap(Item::getName, Item::getValue, (newValue, oldValue) -&gt; newValue));</span><br><span class="line">Map&lt;Integer, Integer&gt; collect3 = list.stream().collect(Collectors.toMap(Item::getName, Item::getValue, (newValue, oldValue) -&gt; newValue));</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>取出list&lt;类&gt;中某一个属性的值，转成新的list</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; collect = list.stream().map(Item::getValue).collect(Collectors.toList());</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>list&lt;类&gt;中进行一组操作，并且转成新的list</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Item&gt; collect1 = list.stream().parallel().map(x -&gt; &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">temp</span> <span class="operator">=</span> x.getName();</span><br><span class="line">    x.setName(x.getValue());</span><br><span class="line">    x.setValue(temp);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;).collect(Collectors.toList());</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="实际消耗">实际消耗</h2>
<p><img src="https://hexo-1304698044.cos.ap-shanghai.myqcloud.com/blog/49c98bb4e7df8b966d8feb3818701e1b.png" alt="49c98bb4e7df8b966d8feb3818701e1b"></p>
<h3 id="选择1、10、100、100-00、100-000的原因">选择1、10、100、100_00、100_000的原因</h3>
<p>1、10、100主要是业务决定的，实际代码编写中这块的数据量是占大头的，10_000，100_000是因为为了查看实际的大数据量情况下的效果。</p>
<p><strong>结果结论如下：</strong></p>
<ol>
<li>如果只是用filter的API，则建议只使用普通for循环，其他情况下数据量较少时，虽然stream和for循环都是10ms以内，但是性能上会差着3-4倍</li>
<li>普通for循环可以使用for (Item item : list)，因为这个是for (int i = 0; i &lt; ; i++)的语法糖，内部是iterator实现</li>
<li>增强for循环底层是Iterator接口，但是实际的验证时发现特别慢，暂时没发现原因，但是不推荐使用</li>
<li>stream串行流转成并行流操作后普遍还是不如串行流快，速度如下：执行时间：串行流转并行流&gt;串行流&gt;并行流，所以串行流转并行流不推荐使用</li>
<li>串行流转并行流和并行流都会使用ForkJoinsPool.commonPool()，这是个进程共用的CPU型线程池，且数据不方便修改，我记得是需要在启动的时候进行修改</li>
<li>串行流转并行流和并行流均会产生线程争抢资源与线程安全问题</li>
<li>在单次stream多次中继操作的情况下，执行速度和单次中继操作差不多</li>
<li>iterator显式使用，在大数据量（1_000_000_000等次循环）的情况下，效率会急速下降，目前原因暂时不清楚。</li>
</ol>
<h2 id="总结">总结</h2>
<ol>
<li>写一次stream操作耗时较少，但是会导致开发人员无意之间多次使用stream流做类似操作（如从订单类中多次取不一致但是相似的一组对象），从而导致可读性变差，不利于后续拓展</li>
<li>尽量使用普通for循环做遍历，迭代器循环做删除或者使用collection的remove、removeIf等API实现（如果只需要删除的话）</li>
<li>使用普通for循环比stream流节省时间，因此在提高性能的角度看开发中尽量使用普通for循环。</li>
</ol>
<hr>
<p>2025年7月12日</p>
<p>实际上stream不只是替代循环操作这么简单，更多的是对集合操作的逻辑进行了抽象。因此stream代码量相比于写for循环更少，并且不只是逻辑处理被抽象了，并发处理也同样可以被抽象；</p>
<p>开发时需要抽象业务实现与并发实现，再进行开发。</p>
<p>引用文章：</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/2132304">【有趣的实验】JAVA 遍历数组的几种方式的耗时对比「建议收藏」</a></li>
<li><a target="_blank" rel="noopener" href="https://www.yisu.com/ask/61585499.html">java foreach循环的底层实现原理</a></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/07/12/%E8%AE%BE%E8%AE%A1/1.DDD%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="annabergite">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="艾迪的技术之路">
      <meta itemprop="description" content="记录博客与成长,Java，架构">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 艾迪的技术之路">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/07/12/%E8%AE%BE%E8%AE%A1/1.DDD%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8%EF%BC%9F/" class="post-title-link" itemprop="url">DDD是什么？怎么使用？</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-07-12 12:06:44 / 修改时间：23:16:11" itemprop="dateCreated datePublished" datetime="2025-07-12T12:06:44+08:00">2025-07-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index"><span itemprop="name">设计</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="前言">前言</h2>
<p>随着业务的不断拓展，一个项目再也不是只需要运行一段时间就可以了，也不是一个很小的项目，随着业务的增长，最终开发的代码会变成一个很大的项目，此时如果不能做好很好的重构，会造成越来越难的拓展，最后导致无法拓展。所以DDD（Domain Driven Design，领域驱动设计）就是从领域业务这个方面对代码做重构与设计的方法论之一。</p>
<p>另外不可能将DDD用于任何一处代码，原因如下：</p>
<ol>
<li>
<p>成本不允许，一般只有项目的核心领域才会考虑使用DDD重构，培养DDD团队会消耗比较长的时间，且整个时间成本是需要持续投入的。</p>
</li>
<li>
<p>因为DDD无法使用于任何一个环境，只使用DDD无法做到满足全部的业务场景，比如G端企业做数据化，很多时候是只需要从数仓查询数据；但是DDD只是一个业务思想，单纯的数据也无法做到成为业务领域</p>
</li>
<li>
<p>DDD要求可以将业务分的很清晰，需要一个“聚合根”将一组业务模型组起来，这要求需要一组业务专家作为开发主力，这通常意味着需要将团队中比较聪明的几位来将项目解构成DDD的模型，很多时候这群人的工作重点不在这里。</p>
</li>
<li>
<p>就算使用DDD也不可能将其全部的教条应用在代码中，因为工作主要是为了盈利，如果使用DDD会帮助提升代码价值，全使用DDD会降低代码价值。在这种情况下，必然是只会使用一部分的DDD思想。</p>
</li>
</ol>
<h2 id="Model-Driven-Design">Model-Driven Design</h2>
<p>好的模型可以反应真实的业务情况</p>
<ol>
<li>
<p>好的模型需要统一的语言，在一个开发团队中，需要让每个开发者对同一个术语的概念是了解一致的，且需要业务专家将对应信息传达下去。</p>
<p>如“数据资产”，数据专家和一个应届生想到的肯定是不一样的。</p>
</li>
<li>
<p>模型类与其他非DDD层的POJO需要分离开来，尤其需要和数据库的POJO分离开来，DDD是软件设计思想，与数据库、技术组件、远程调用是完全不相关的。</p>
</li>
<li>
<p>除了核心组件外，其他组件，如MVC的DAO层，因为其确实是需要做到和固定数据库做好对接，所以面向结果编程是完全值得提倡的。</p>
</li>
<li>
<p>DDD中一组很重要的思想是Entity和Value Object，Entity可以被认为是数据库中一张表的自增主键，具有连续性和唯一性，Value Object相当于是一个更关注其数据属性的一个组件，因此只能依附于一个Entity</p>
</li>
<li>
<p>Entity和Value Object只是提供了一组事物信息，如广告转化率、广告使用地区等。但是另外还需要非“事物”的部分引入到模型中，如行为，如一组模型相关的业务，如广告投放业务中，如果需要对广告相关的信息做校验，其中就包括业务校验和技术校验，如果将这两个模块混淆了，则会导致业务层被“腐化”，无法实现很好的解耦与以后的拓展，因此需要将业务操作和技术操作分离出来，我们可以将基于Entity和Value Object的操作称之为“Service”。</p>
<p>模型中的Service有应用层面的Service、领域层面的Service（因为需要将真实业务层和技术实现层解耦，在Java的开发中可以使用依赖反转实现）、技术层的Service，应用层面的Service、领域层面的Service无法很好的区分，有时候可能不需要做区分，但是一旦涉及到业务领域核心，且不已不同应用场景为变更，则可能需要区分。</p>
<p>以下有一个例子：</p>
<p>在C端进行广告投放业务，会需要做到以下代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AdvertisementService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    OnlineRetailersFeign onlineRetailersFeign;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    AdvertisementDAO advertisementDAO;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    AdvertisementDomainService advertisementDomainService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Result&lt;AdvertisementDTO&gt; <span class="title function_">showAdvertisementInfo</span><span class="params">(AdvertisementRequestAO advertisementRequestAO)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">reginId</span> <span class="operator">=</span> advertisementRequestAO.getReginId();</span><br><span class="line">        <span class="comment">//查看广告校验是否有效</span></span><br><span class="line">        <span class="keyword">if</span> (checkAdvertisementDisable(reginId)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>&lt;AdvertisementDTO&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//进行本业务相关操作</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 1.查看投放地域、用户信息，查看用户所处环境（APP、Web等）</span></span><br><span class="line"><span class="comment">         * 2.从数据库中取出用户个人画像、当地广告服务商提供的服务</span></span><br><span class="line"><span class="comment">         * 3.通过算法取得合适的投放信息，并且按照需要从电商微服务等服务获取信息包装</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        advertisementDomainService.domainOperate();</span><br><span class="line">        <span class="comment">//最后进行写入数据库操作</span></span><br><span class="line">        advertisementDAO.insert();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//给其他微服务发送对应消息</span></span><br><span class="line">        onlineRetailersFeign.notify();</span><br><span class="line">        <span class="comment">//最后返回信息</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>&lt;AdvertisementDTO&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 校验广告地址信息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> reginId</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">checkAdvertisementDisable</span><span class="params">(String reginId)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>其中最重要的是advertisementDomainService.domainOperate()，这个可以认为是领域相关Service，不能算作是应用Service，应用Serivce可以是advertisementDomainService.domainOperate()中的实现，通过状态模式/策略模式，实现具体逻辑。因为取得服务可能因为地区、用户不同、具体的实现逻辑是不一样的，调用的组件是不一样的，所以细节上的实现需要应用层去协调和跟技术层Service实现，但是总的来说，投放一个广告就是需要这几步，因此这一组需要作为领域层的Service。</p>
<p>Service是当需要Entity和Value Object做一组操作时候出现的，且Service最好是无状态的。</p>
</li>
<li>
<p>最后的Entity和Value Object应当以一组模块的形式出现。</p>
</li>
</ol>
<h2 id="业务域">业务域</h2>
<ol>
<li>设计好模型后就需要将模型组合成为领域，那么就需要一个model作为聚合根实现聚合。其中占主导作用的，和外部做主要交互的model作为聚合根，是这个领域存在的前提条件。</li>
<li>开发一个领域就是为了让隐性概念显性化，让隐形上下文显性化，配置多对象行为。</li>
<li>需要根据业务需要将领域划分为核心子域、支撑子域、通用子域。这些领域之间需要做到可以使用限界上下文、通用语言、上下文映射图做好划分。</li>
<li>限界上下文是当一个领域形成时候，需要将业务与其他业务进行物理隔离，只能通过几个固定方式进行交互，这个边界就是限界上下文</li>
</ol>
<h2 id="战略战术">战略战术</h2>
<h2 id="总结">总结</h2>
<ol>
<li>只学习DDD并不能帮你更好的架构与设计，更好的方式应当是学习软件常见的架构设计模式、自己使用的编程语言的基本特性、然后再积极的使用</li>
<li>（另外就是Eric Evans的软件驱动设计：软件核心复杂性应对之道不推荐看，因为翻译比较捉襟见肘，很多时候不知道在讲什么）</li>
<li>DDD思想知易行难，期间需要花大量精力打通多个团队，是个人硬实力与软实力的体现，另外就是需要正确的构建出模型，需要可以满足实际的需要。实践DDD思想是一项风险收益都较高的事情。</li>
</ol>
<ul>
<li>避免胶水依赖</li>
<li>修改目标：接口语义明确，可拓展性强，最好带有自检性；参数校验逻辑复用，内聚；参数校验一场和业务逻辑异常解耦。</li>
<li>单元测试可行性（至少要满足从跑CI）</li>
<li>让隐性概念显性化，让隐形上下文显性化，配置多对象行为</li>
<li>DP（Domain Primitive）</li>
<li>将其中的技术框架、中间件等五控制权，可以替换的、非核心业务域的组件给去除掉。</li>
<li>比如，业务类和数据库DO类就不是同一个类。</li>
<li>一个系统需要和它使用的数据库进行解耦</li>
<li>Repository（数据访问抽象层）只定义动作。</li>
<li>下水道逻辑（Dao层，可以想做什么就做什么）</li>
<li>如果不使用合理的耦合方式，那么就会出现M个业务如果进行修改且相互耦合，那就代表一次拓展需要做M²次修改，如果遵循各种架构的优化方式，则可以做到一次拓展只需要修改2M次服务。</li>
<li>业务总览-&gt;业务划分-&gt;业务编排Entity、Domain Service、最后做一些解耦中的具体实现</li>
<li>聚合根、限界上下文</li>
<li>value Object与Domain Service</li>
</ul>
<h2 id="引用文章">引用文章</h2>
<ol>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/703520265">DDD在软件开发实践中的应用(一）- Ubiquitous Language</a></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/07/12/%E5%BC%80%E5%8F%91/2.Java%E7%9A%84Map%E5%A2%9E%E5%BC%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="annabergite">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="艾迪的技术之路">
      <meta itemprop="description" content="记录博客与成长,Java，架构">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 艾迪的技术之路">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/07/12/%E5%BC%80%E5%8F%91/2.Java%E7%9A%84Map%E5%A2%9E%E5%BC%BA/" class="post-title-link" itemprop="url">Java的Map增强</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-07-12 12:05:20 / 修改时间：23:16:11" itemprop="dateCreated datePublished" datetime="2025-07-12T12:05:20+08:00">2025-07-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">开发</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>增强 guava 的 Maps. uniqueIndex方法<br>
guava 的 Maps. uniqueIndex方法可以实现： 将 list<V> 转成 Map&lt;K , V&gt; K 需要自己指定， V不能指定<br>
本方法实现了：<br>
将 list<V> 转成 Map&lt;K , M&gt; K 需要自己指定， M需要自己指定<br>
其中K不能重复，若重复，则会报错<br>
Params:<br>
values – 需要转换的集合 可以是任何实现了 Iterable 接口的集合(如List, Set, Collection) keyFunction – 转换后Map的键的转换方式 valueFunction – 转换后Map的值的转换方式<br>
Returns:<br>
唯一的map</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;K, V, M&gt; ImmutableMap&lt;K, M&gt; <span class="title function_">uniqueIndex</span><span class="params">(Iterable&lt;V&gt; values, Function&lt;? <span class="built_in">super</span> V, K&gt; keyFunction, Function&lt;? <span class="built_in">super</span> V, M&gt; valueFunction)</span> &#123;</span><br><span class="line">        Iterator&lt;V&gt; iterator = values.iterator();</span><br><span class="line">        checkNotNull(keyFunction);</span><br><span class="line">        checkNotNull(valueFunction);</span><br><span class="line">        ImmutableMap.Builder&lt;K, M&gt; builder = ImmutableMap.builder();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            <span class="type">V</span> <span class="variable">value</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">            builder.put(keyFunction.apply(value), valueFunction.apply(value));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> builder.build();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalArgumentException duplicateKeys) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line">                    duplicateKeys.getMessage()</span><br><span class="line">                            + <span class="string">&quot;.若要在键下索引多个值，请使用: Multimaps.index.&quot;</span>, duplicateKeys);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>一个key 对应多个值的map 结构： key -&gt; [value1, value2, …]<br>
Params:<br>
values – 需要转换的集合 可以是任何实现了 Iterable 接口的集合(如List, Set, Collection) keyFunction – 转换后Map的键的转换方式 valueFunction – 转换后Map的值的转换方式<br>
Returns:<br>
唯一的map</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;K, V, M&gt; Multimap&lt;K, M&gt; <span class="title function_">iterableToMultiMap</span><span class="params">(Iterable&lt;V&gt; values, Function&lt;? <span class="built_in">super</span> V, K&gt; keyFunction, Function&lt;? <span class="built_in">super</span> V, M&gt; valueFunction)</span> &#123;</span><br><span class="line">        Iterator&lt;V&gt; iterator = values.iterator();</span><br><span class="line">        checkNotNull(keyFunction);</span><br><span class="line">        checkNotNull(valueFunction);</span><br><span class="line"></span><br><span class="line">        Multimap&lt;K, M&gt; builder = ArrayListMultimap.create();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            <span class="type">V</span> <span class="variable">value</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">            builder.put(keyFunction.apply(value), valueFunction.apply(value));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> builder;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalArgumentException duplicateKeys) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line">                    duplicateKeys.getMessage()</span><br><span class="line">                            + <span class="string">&quot;.若要在键下索引多个值，请使用: Multimaps.index.&quot;</span>, duplicateKeys);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>转换 Map 的 K 和 V<br>
Params:<br>
map – map<br>
Returns:<br>
反转的map</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;K, V&gt; Map&lt;V, K&gt; <span class="title function_">inverse</span><span class="params">(Map&lt;K, V&gt; map)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (MapUtil.isEmpty(map)) &#123;</span><br><span class="line">            <span class="keyword">return</span> Collections.emptyMap();</span><br><span class="line">        &#125;</span><br><span class="line">        HashBiMap&lt;K, V&gt; biMap = HashBiMap.create();</span><br><span class="line">        map.forEach(biMap::forcePut);</span><br><span class="line">        <span class="keyword">return</span> biMap.inverse();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>按照分隔符切割list<br>
Params:<br>
list – 集合 function – 转换器 separator – 分隔符<br>
Returns:<br>
分割后的集合</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; List&lt;String&gt; <span class="title function_">split</span><span class="params">(Collection&lt;T&gt; list, Function&lt;? <span class="built_in">super</span> T, ?&gt; function, CharSequence separator)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (CollUtil.isEmpty(list)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list.parallelStream().map(function).map(item -&gt; StrUtil.splitToArray(String.valueOf(item), separator))</span><br><span class="line">                .flatMap(Arrays::stream).filter(ObjectUtil::isNotEmpty).distinct().collect(Collectors.toList());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>按照分隔符切割list<br>
Params:<br>
list – 集合 separator – 分隔符<br>
Returns:<br>
分割后的集合</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; List&lt;String&gt; <span class="title function_">split</span><span class="params">(Collection&lt;String&gt; list, CharSequence separator)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (CollUtil.isEmpty(list)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list.parallelStream().map(item -&gt; StrUtil.splitToArray(item, separator))</span><br><span class="line">                .flatMap(Arrays::stream).filter(ObjectUtil::isNotEmpty).distinct().collect(Collectors.toList());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/07/12/%E5%BC%80%E5%8F%91/3.spring%E4%B8%AD%E7%9A%84async%E3%80%81schedule%E7%9A%84%E7%BA%BF%E7%A8%8B%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="annabergite">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="艾迪的技术之路">
      <meta itemprop="description" content="记录博客与成长,Java，架构">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 艾迪的技术之路">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/07/12/%E5%BC%80%E5%8F%91/3.spring%E4%B8%AD%E7%9A%84async%E3%80%81schedule%E7%9A%84%E7%BA%BF%E7%A8%8B%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">spring中的async、schedule的线程问题</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-07-12 11:59:29 / 修改时间：23:16:11" itemprop="dateCreated datePublished" datetime="2025-07-12T11:59:29+08:00">2025-07-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">开发</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ul>
<li>除了Java自带默认线程池，基于Java的spring框架也有很多自带的默认线程池，有时候我们的一些需要线程池的操作可能通过提供的api和注解隐藏掉了，不熟悉的话会出现线程相关的问题</li>
</ul>
<h2 id="1-Future和CompletableFuture">1 Future和CompletableFuture</h2>
<p>Future和CompletableFuture都是Java提供的用来执行异步方法的情况。其中，Future只能包装一个异步任务，最后还是要把这个任务提交给特定线程池。</p>
<p>CompletableFuture则会使用默认线程池，但是比较复杂：</p>
<ul>
<li>
<p>无JVM参数前提下：</p>
<p>若服务器的核心数小于等于2，commonParallelism 则为1，即useCommonPool 为false，new 一个线程池ThreadPerTaskExecutor 。</p>
<p>若服务器的核心数大于2，commonParallelism 则为 核心数 - 1，即useCommonPool 为true，使用ForkJoinPool线程池。</p>
</li>
<li>
<p>有JVM参数情况下：</p>
<p>以设置参数为准。大于1小于等于32767。和上面判断一致</p>
</li>
</ul>
<p>以上CompletableFuture的总结来自 这篇文章 <a target="_blank" rel="noopener" href="https://blog.csdn.net/belongtocode/article/details/139218832">从用法到源码再到应用场景：全方位了解CompletableFuture及其线程池</a> 有兴趣深挖一下的可以看下</p>
<p>综上我们推荐使用CompletableFuture时候也需要主动指定线程池，没有指定线程池的情况下，CompletableFuture要么使用ForkJoinPool，要么不使用线程池，ForkJoinPool做CPU密集型任务好用，我们有时候做IO密集型任务则不需要他，需要指定IO型线程池。</p>
<h2 id="2-hutool的异步任务">2 hutool的异步任务</h2>
<p>hutool在提交任务的时候，会自动提交到一个默认的ExecutorService对象中，这个对象会使用如下的类的builder(0方法，这个对象的参数如下</p>
<p>一些小项目直接使用OK的，但是如果大项目使用的话，风险会较大，他的最大线程数是最大值，任务队列也是1024，不一定满足业务需要，核心线程数是0</p>
<p><img src="C:%5CUsers%5Czhubaiyi%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240818161541264.png" alt="image-20240818161541264"></p>
<h2 id="3-Async">3 @Async</h2>
<p>springboot 2.1.0 之前：simpleasynctaskexecutor，这个线程池会是不安全的线程池，很容易出现OOM，因为他创建新线程、无限、不重用</p>
<p>springboot 2.1.0 之后：taskexecutor这个是springboot的一个自带bean，类型是TaskExecutor，一般是有的，如果没有才会找simpleasynctaskexecutor</p>
<h2 id="4-Schedule">4 @Schedule</h2>
<p>在Spring Boot中，@Scheduled注解是基f于Java的ThreadPoolExecutor和ScheduledThreadPoolExecutor实现的。当我们配置了一个定时任务后，Spring Boot会首先创建一个ScheduledThreadPoolExecutor线程池，并将定时任务添加到该线程池中等待执行。然后，在指定的时间到来之后，线程池会为该定时任务分配一个线程来执行。如果该定时任务还未执行完毕，在下一个周期到达时，线程池会为该任务再次分配一个线程来执行。通过这种方式，@Scheduled可以非常方便地实现周期性的定时任务f于Java的ThreadPoolExecutor和ScheduledThreadPoolExecutor实现的。</p>
<p>当然schedule注解可以指定线程池，需要实现SchedulingConfigurer 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@DependOn(&quot;executor&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScheduleConfig</span> <span class="keyword">implements</span> <span class="title class_">SchedulingConfigurer</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> ThreadPoolExecutor executor;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureTasks</span><span class="params">(ScheduledTaskRegistrar taskRegistrar)</span> &#123;</span><br><span class="line">        <span class="comment">//具体逻辑需要自己写</span></span><br><span class="line">        <span class="type">ThreadPoolTaskScheduler</span> <span class="variable">threadPoolTaskScheduler</span> <span class="operator">=</span> executor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>或者可以再schedule注解上再加一个 @Async注解，做到异步线程中去做。</p>
<h2 id="5-stream-Parallel">5 stream Parallel</h2>
<p>parallelStream不能使用自定义线程池，默认情况下，Stream使用的是<code>ForkJoinPool.commonPool()</code>，这是一个公用的线程池，被整个程序所使用。</p>
<p>但是stream parallel本身就符合ForkJoinPool的Fork/Join思想，一般不会去进行修改。但是如果有需要，我们可以单独给并行流创建一个线程池供他们使用。</p>
<p>如创建一个并行度为4的ForkJoinPool，通过给该ForkJoinPool提交lambda表达式任务来解决这个问题</p>
<h2 id="6-ForkJoinPool">6 ForkJoinPool</h2>
<p>详情可以参照该文章 <a target="_blank" rel="noopener" href="https://javakk.com/215.html">线程池ForkJoinPool简介</a></p>
<h2 id="7-Transactional">7 @Transactional</h2>
<p>使用该注解时不能做和多线程/异步线程相关的事情，否则事务容易失效，详情请见 <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_37284798/article/details/129164113">注解@Transactional 原理和常见的坑</a></p>
<p>引用文章：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://maimai.cn/article/detail?fid=1505153744&amp;efid=rQBm3tkC-gPFkpO886YBcg">Spring中异步注解@Async的使用、原理及使用时可能导致的问题</a></li>
<li><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1jE421w732/">Async注解不指定线程池？默认用的又是什么？</a></li>
<li><a target="_blank" rel="noopener" href="https://doc.hutool.cn/">hutool官网</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/belongtocode/article/details/139218832">从用法到源码再到应用场景：全方位了解CompletableFuture及其线程池</a></li>
<li><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/2272968">SpringBoot定时任务@Scheduled的多线程使用</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_37284798/article/details/129164113">注解@Transactional 原理和常见的坑</a></li>
<li><a target="_blank" rel="noopener" href="https://javakk.com/215.html">线程池ForkJoinPool简介</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_33709582/article/details/132686293">多线程场景下谨慎使用@Transactional注解，你不信我也没办法</a></li>
</ul>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_33709582/article/details/132686293">https://blog.csdn.net/qq_33709582/article/details/132686293</a>)</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/07/12/%E5%BC%80%E5%8F%91/1.superset%E5%AE%89%E8%A3%85%E6%96%87%E6%A1%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="annabergite">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="艾迪的技术之路">
      <meta itemprop="description" content="记录博客与成长,Java，架构">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 艾迪的技术之路">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/07/12/%E5%BC%80%E5%8F%91/1.superset%E5%AE%89%E8%A3%85%E6%96%87%E6%A1%A3/" class="post-title-link" itemprop="url">superset安装文档</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-07-12 11:55:41 / 修改时间：23:16:11" itemprop="dateCreated datePublished" datetime="2025-07-12T11:55:41+08:00">2025-07-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">开发</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="1、Superset安装步骤">1、Superset安装步骤</h2>
<p>superset官网 <a target="_blank" rel="noopener" href="http://superset.apache.org/">http://superset.apache.org/</a></p>
<p>superset对于python有版本要求，最好是最新版的python，因此需要安装python虚拟环境，方面部署。</p>
<p>superset有window安装方法，Linux的虚拟python环境安装方法，以及Linux的docker安装方法，一下为Linux虚拟python环境安装docker的方法</p>
<h3 id="1-1-superset安装步骤">1.1 superset安装步骤</h3>
<p>安装superset的完全步骤如下：</p>
<p>安装miniconda-&gt;在miniconda中为superset创建python虚拟环境-&gt;安装superset</p>
<p><strong>安装过程需要全程联网</strong></p>
<h2 id="2、安装Miniconda">2、安装Miniconda</h2>
<p>为什么不用anaconda或者是conda？</p>
<p>因为anaconda环境内容较多，安装superset不需要较多工具</p>
<p>下载Miniconda（Python3版本）的地址为：<a target="_blank" rel="noopener" href="https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh">https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh</a></p>
<p>按照以下命令进行安装，根据提示进行操作完成安装</p>
<h4 id="拉取安装脚本">拉取安装脚本</h4>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash Miniconda3-latest-Linux-x86_64.sh </span><br></pre></td></tr></table></figure>
<p>在一开始阅读协议的时候可以按空格键快速阅读</p>
<p>笔者在使用命令安装时的安装miniconda地址为</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/opt/module/miniconda3</span><br></pre></td></tr></table></figure>
<h4 id="加载配置">加载配置</h4>
<p>加载环境变量配置文件，使之生效</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure>
<p>Miniconda安装完成后，每次打开终端都会激活其默认的base环境，我们可通过以下命令，禁止激活默认base环境。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda config --set auto_activate_base false</span><br></pre></td></tr></table></figure>
<h2 id="3、创建python-3-10-4环境">3、创建python 3.10.4环境</h2>
<h4 id="配置conda镜像">配置conda镜像</h4>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free</span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main</span><br><span class="line">conda config --set show_channel_urls yes</span><br></pre></td></tr></table></figure>
<h4 id="创建python环境">创建python环境</h4>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda create --name superset python=3.10.4</span><br></pre></td></tr></table></figure>
<p><strong>conda环境管理常用命令</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">创建环境：conda create -n env_name</span><br><span class="line">查看所有环境：conda info --envs</span><br><span class="line">删除一个环境：conda remove -n env_name --all</span><br></pre></td></tr></table></figure>
<h4 id="激活环境">激活环境</h4>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda activate superset</span><br></pre></td></tr></table></figure>
<p>如果想退出当前环境，使用如下命令</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda deactivate</span><br></pre></td></tr></table></figure>
<h2 id="4、安装superset">4、安装superset</h2>
<h4 id="安装依赖">安装依赖</h4>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install -y gcc gcc-c++ libffi-devel python-devel python-pip python-wheel python-setuptools openssl-devel cyrus-sasl-devel openldap-devel</span><br></pre></td></tr></table></figure>
<h4 id="安装（更新）setuptools和pip">安装（更新）setuptools和pip</h4>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install --upgrade setuptools pip -i https://pypi.douban.com/simple/</span><br></pre></td></tr></table></figure>
<h4 id="安装superset">安装superset</h4>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install apache-superset -i https://pypi.douban.com/simple/</span><br></pre></td></tr></table></figure>
<p>说明：-i的作用是指定镜像，这里选择国内镜像<br>
注：如果遇到网络错误导致不能下载，可尝试更换镜像</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install apache-superset --trusted-host https://repo.huaweicloud.com -i https://repo.huaweicloud.com/repository/pypi/simple</span><br></pre></td></tr></table></figure>
<h4 id="初始化Supetset数据库">初始化Supetset数据库</h4>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">superset db upgrade</span><br></pre></td></tr></table></figure>
<h4 id="创建管理员账户">创建管理员账户</h4>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export FLASK_APP=superset</span><br><span class="line">superset fab create-admin</span><br><span class="line">superset init</span><br></pre></td></tr></table></figure>
<p><strong>修改密码</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">superset fab reset-password --username admin --password 123456</span><br></pre></td></tr></table></figure>
<p>username后面需要改成你想修改的用户的用户名，不需要修改</p>
<p>password后面为后续想改成的密码</p>
<p>修改完成后需要执行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">superset init</span><br></pre></td></tr></table></figure>
<p>重启</p>
<h2 id="5、启动superset">5、启动superset</h2>
<h4 id="安装gunicorn">安装gunicorn</h4>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install gunicorn -i https://pypi.douban.com/simple/</span><br></pre></td></tr></table></figure>
<p>说明：gunicorn是一个Python Web Server，可以和java中的TomCat类比</p>
<p>启动Superset<br>
首先确保当前conda环境为superset，及下图所示</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/b9605c3199d7708dda505a974ef112d4.jpeg" alt="https://pic.imgdb.cn/item/649d24da1ddac507cc198c90.jpg"></p>
<h4 id="启动">启动</h4>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gunicorn --workers 5 --timeout 120 --bind 172.16.150.14:5000  &quot;superset.app:create_app()&quot; --daemon </span><br></pre></td></tr></table></figure>
<p>说明：<br>
–workers：指定进程个数,python脚本语言没有线程概念<br>
–timeout：worker进程超时时间，超时会自动重启<br>
–bind：绑定本机地址，即为Superset访问地址<br>
–daemon：后台运行</p>
<p>需要保证后续可以登录，需要保证防火墙关闭（不推荐）或者是开启端口并且重启防火墙</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重启防火墙</span></span><br><span class="line">firewall-cmd --reload</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">开启防火墙</span></span><br><span class="line">systemctl start firewalld</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">关闭防火墙</span></span><br><span class="line">systemctl stop firewalld</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">防火墙版本</span></span><br><span class="line">firewall-cmd --version</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">防火墙状态</span></span><br><span class="line">systemctl status firewalld</span><br><span class="line">firewall-cmd --query-port=80/tcp</span><br><span class="line">firewall-cmd --permanent --list-ports</span><br><span class="line">firewall-cmd --permanent --add-port=8080/tcp</span><br><span class="line">firewall-cmd --permanent --add-port=8083-8085/tcp</span><br><span class="line">firewall-cmd --permanent --remove-port=8083-8085/tcp</span><br></pre></td></tr></table></figure>
<h2 id="6、遇到的问题以及解决">6、遇到的问题以及解决</h2>
<h5 id="报错1">报错1</h5>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(superset) [hyj@hadoop102 ~]$ superset db upgrade</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">然后包这些错误</span></span><br><span class="line">    from markupsafe import soft_unicode</span><br><span class="line">ImportError: cannot import name &#x27;soft_unicode&#x27; from &#x27;markupsafe&#x27; (/opt/module/miniconda3/envs/superset/lib/python3.7/site-packages/markupsafe/__init__.py)</span><br></pre></td></tr></table></figure>
<p><strong>解决方法</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看markupsafe这个包是否存在</span></span><br><span class="line">(superset) [hyj@hadoop102 ~]$ pip show markupsafe</span><br><span class="line">Name: MarkupSafe</span><br><span class="line">Version: 2.1.2</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">下载2.0.1版本的markupsafe (pip会帮我们卸载之前版本的并下载2.0.1版本的markupsafe)</span></span><br><span class="line">(superset) [hyj@hadoop102 ~]$ pip install markupsafe==2.0.1</span><br></pre></td></tr></table></figure>
<h5 id="报错2">报错2</h5>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(superset) [hyj@hadoop102 ~]$ superset db upgrade</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">但是会报这个错误</span></span><br><span class="line">re.compile(r&quot;&#x27;(&#x27;&#x27;|\\\\|\\|[^&#x27;])*&#x27;&quot;, sqlparse.keywords.FLAGS).match,</span><br><span class="line">AttributeError: module &#x27;sqlparse.keywords&#x27; has no attribute &#x27;FLAGS&#x27;</span><br></pre></td></tr></table></figure>
<p><strong>解决方法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install sqlparse==&#x27;0.4.3&#x27;</span><br></pre></td></tr></table></figure>
<h5 id="报错3">报错<strong>3</strong></h5>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">superset db upgrade</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">报错</span></span><br><span class="line">Error: Could not locate a Flask application. </span><br><span class="line">You did not provide the &quot;FLASK_APP&quot; environment variable, and a &quot;wsgi.py&quot; or &quot;app.py&quot; module was not found in the current directory.</span><br></pre></td></tr></table></figure>
<p><strong>解决方法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export FLASK_APP=superset</span><br></pre></td></tr></table></figure>
<h5 id="报错4">报错4</h5>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">superset db upgrade</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">但是遇到如下问题</span></span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">                                    WARNING</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">A Default SECRET_KEY was detected, please use superset_config.py to override it.</span><br><span class="line">Use a strong complex alphanumeric string and use a tool to help you generate </span><br><span class="line">a sufficiently random sequence, ex: openssl rand -base64 42</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">Refusing to start due to insecure SECRET_KEY</span><br></pre></td></tr></table></figure>
<p><strong>解决方法</strong></p>
<p>进入到miniconda3的安装路径下的envs/superset/lib/python+版本号/目录</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(superset) [hyj@hadoop102 ~]$ cd /opt/module/miniconda3/envs/superset/lib/python3.8/</span><br></pre></td></tr></table></figure>
<p>创建superset_config.py</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim superset_config.py</span><br></pre></td></tr></table></figure>
<p>添加如下行为</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SECRET_KEY = &quot;ZT2uRVAMPKpVkHM/QA1QiQlMuUgAi7LLo160AHA99aihEjp03m1HR6Kg&quot; </span><br><span class="line">用命令 openssl rand -base64 42 来生成一个强密钥</span><br><span class="line">openssl rand -base64 42</span><br><span class="line">4xPjBius42o5Y/pbgRmkjKZ3im5CeHcRXM93TWm+FboEJOll0XMMgDRW</span><br><span class="line">所以SECRET_KEY =“4xPjBius42o5Y/pbgRmkjKZ3im5CeHcRXM93TWm+FboEJOll0XMMgDRW”</span><br></pre></td></tr></table></figure>
<h5 id="报错5">报错5</h5>
<p>yum命令无法查找到镜像mirror，下载不了文件的问题</p>
<p><strong>解决</strong></p>
<p>要么配置本地源（不推荐），要么网络拉取镜像源（推荐），下面有网络拉取镜像源的步骤</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">安装wget工具</span></span><br><span class="line">yum intall -y wget 	</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">转到yum源文件存放路径</span></span><br><span class="line">cd /etc/yum.repos.d/	</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">创建一个网络yum源文件备份</span></span><br><span class="line">tar zcf backup_repo.tar.gz *	</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">删除所有yum源文件</span></span><br><span class="line">rm -rf CentOS*		</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">下载yum源文件</span></span><br><span class="line">wget http://mirrors.aliyun.com/repo/Centos-7.repo	</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">清除缓存</span></span><br><span class="line">yum clean all </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">重新搭载yum源</span></span><br><span class="line">yum makecache </span><br></pre></td></tr></table></figure>
<p>登录</p>
<p>访问<a target="_blank" rel="noopener" href="http://hadoop102:5000/">http://hadoop102:5000</a>，并使用之前安装superset过程中设置的用户名密码登录</p>
<p>停止superset</p>
<p>如果想要停止superset则使用如下命令</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | awk &#x27;/superset/ &amp;&amp; !/awk/&#123;print $2&#125;&#x27; | xargs kill -9</span><br></pre></td></tr></table></figure>
<h4 id="使用superset启停脚本进行项目的启停">使用superset启停脚本进行项目的启停</h4>
<p>其中IP地址和端口需要根据实际情况进行更改</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim superset.sh</span><br></pre></td></tr></table></figure>
<p>内容如下</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">superset_status()&#123;</span><br><span class="line">    result=`ps -ef | awk &#x27;/gunicorn/ &amp;&amp; !/awk/&#123;print $2&#125;&#x27; | wc -l`</span><br><span class="line">    if [[ $result -eq 0 ]]; then</span><br><span class="line">        return 0</span><br><span class="line">    else</span><br><span class="line">        return 1</span><br><span class="line">    fi</span><br><span class="line">&#125;</span><br><span class="line">superset_start()&#123;</span><br><span class="line">        source ~/.bashrc</span><br><span class="line">        superset_status &gt;/dev/null 2&gt;&amp;1</span><br><span class="line">        if [[ $? -eq 0 ]]; then</span><br><span class="line">            conda activate superset ; gunicorn --workers 5 --timeout 120 --bind IP地址:端口 --daemon &#x27;superset.app:create_app()&#x27;</span><br><span class="line">        else</span><br><span class="line">            echo &quot;superset正在运行&quot;</span><br><span class="line">        fi</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">superset_stop()&#123;</span><br><span class="line">    superset_status &gt;/dev/null 2&gt;&amp;1</span><br><span class="line">    if [[ $? -eq 0 ]]; then</span><br><span class="line">        echo &quot;superset未在运行&quot;</span><br><span class="line">    else</span><br><span class="line">        ps -ef | awk &#x27;/gunicorn/ &amp;&amp; !/awk/&#123;print $2&#125;&#x27; | xargs kill -9</span><br><span class="line">    fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">case $1 in</span><br><span class="line">    start )</span><br><span class="line">        echo &quot;启动Superset&quot;</span><br><span class="line">        superset_start</span><br><span class="line">    ;;</span><br><span class="line">    stop )</span><br><span class="line">        echo &quot;停止Superset&quot;</span><br><span class="line">        superset_stop</span><br><span class="line">    ;;</span><br><span class="line">    restart )</span><br><span class="line">        echo &quot;重启Superset&quot;</span><br><span class="line">        superset_stop</span><br><span class="line">        superset_start</span><br><span class="line">    ;;</span><br><span class="line">    status )</span><br><span class="line">        superset_status &gt;/dev/null 2&gt;&amp;1</span><br><span class="line">        if [[ $? -eq 0 ]]; then</span><br><span class="line">            echo &quot;superset未在运行&quot;</span><br><span class="line">        else</span><br><span class="line">            echo &quot;superset正在运行&quot;</span><br><span class="line">        fi</span><br><span class="line">esac</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>加执行权限</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x superset.sh</span><br></pre></td></tr></table></figure>
<p>怎么使用这些指令</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动superset</span></span><br><span class="line">superset.sh start</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">停止superset</span></span><br><span class="line">superset.sh stop</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重启superset</span></span><br><span class="line">superset.sh restart</span><br></pre></td></tr></table></figure>
<h1>自助分析平台使用教程</h1>
<p>自助分析平台自身使用软件自带的sqlite软件对于信息进行存储<br>
应用效果如图所示</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/4c4f3a18975775fc7b110d51fec73b7e.jpeg" alt=""></p>
<p>其中主要部分用于展示自制的页面列表，自助分析平台有如下几个重要的组成元素：</p>
<ul>
<li><strong>仪表盘（dashboard）</strong></li>
<li><strong>各种数据图形（chart）</strong></li>
<li><strong>数据集（dataset）</strong></li>
<li><strong>数据源（database）</strong></li>
</ul>
<p>而创建一个完整的图表过程下所示</p>
<h2 id="1、配置展示的数据源">1、配置展示的数据源</h2>
<p>点击右上角setting，在下拉框列表中勾选database connection</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/3132d29db8065618fdb799f25f36f28e.jpeg" alt=""></p>
<p>再点击<img src="https://img-blog.csdnimg.cn/img_convert/afb508620570481a83586caea1bbdf1c.jpeg" alt=""></p>
<p>可以添加数据源，填写好配置后既可使用该数据源拿取数据</p>
<h2 id="2、创建页面">2、创建页面</h2>
<p>在主页中点击 添加database，即可添加新页面</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/26a4ae24279225f2d129ba2f34b562bb.jpeg" alt=""></p>
<p>创建页面的页面效果如图所示</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/4bbbe88a4294755ed76361f83ba37abb.jpeg" alt=""></p>
<p>其中charts为可以用于填充页面的图表，需要自己制作，layout elements是布局元素，可以添加一定的预设填充页面，比如一部分markdown编辑组件，规定自制图表大小和位置的页面结构</p>
<p>如果没有图表，需要自己创作</p>
<h2 id="3、创建图表">3、创建图表</h2>
<p>点击任何和图标相关的信息即可跳转到创建图表页面</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/ea9311cd319820760d19e711b4b9b4cd.jpeg" alt=""></p>
<p>分为两步，第一步选择数据集，第二步为选择图表样式</p>
<h4 id="3-1创建数据集">3.1创建数据集</h4>
<p>点击add a dataset后可以跳转到安装数据源的页面，这个功能的意思就是从设置的数据源中拿到一张表，作为一个数据源</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/3686295e79e44f4a3bcf1bb5bf5a0202.jpeg" alt=""></p>
<p>点击dataset，会让你从已经设置的数据源中选择一个作为数据源，</p>
<p>schema则为让你在选择的数据源中选择一个schema，</p>
<p>选择完成后会产生新的下拉框选项</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/06d452203a3ad1a307c8f12e97daa7fa.jpeg" alt=""></p>
<p>即为选择相应的表</p>
<p>选择后点击右下角的 create dataset and  create chart，即为创建完成</p>
<h4 id="3-2选择图表">3.2选择图表</h4>
<p><img src="https://img-blog.csdnimg.cn/img_convert/6e1ea02ea838fd94eb22020506f66a81.jpeg" alt=""></p>
<h2 id="4、编辑图表">4、编辑图表</h2>
<p>编辑图表界面如图所示</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/1a5b35e56e1c5883ec7df63c851e92b7.jpeg" alt=""></p>
<p>主要的部分为1、2、3、4共4各部分，其中</p>
<p>1为图表名称</p>
<p>2为数据集的信息展示，对于此部分了解的人员可以隐藏不看该部分</p>
<p>3为确认横坐标和纵坐标的信息</p>
<p><strong>time</strong>与横坐标信息强绑定了，如果使用时间顺序折线图的话，必须从表中选择时间类型的属性作为横坐标，其中</p>
<p><strong>time column</strong>为选择哪一个数据集中的属性作为x轴</p>
<p><strong>time grain</strong>为单位，是哪一个时间维度作为单位</p>
<p><strong>time range</strong>为查询的时间跨度是多少，可以不过滤</p>
<p><strong>Query</strong>为y轴部分</p>
<p><strong>METRIC</strong>可以用于选择哪一个数据集中的属性作为y轴信息，以及这个字段中数据以什么样的聚合函数形式展示，比如平均，还是求和，还是极值</p>
<p><strong>FILTERS</strong>可以用于作为过滤条件，即对于数据进行条件判断，适合条件的才会做处理</p>
<p>第4部分为数据的可视化展示</p>
<p>处理完成后即可进行保存</p>
<p><strong>值得注意的是，目前自主分析平台可以制作多种图表，已经可以满足各种类型图表的制作</strong></p>
<h2 id="5、填充页面并保存">5、填充页面并保存</h2>
<p>再次回到页面编辑界面，此时我们已经有了数个图表</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/68ba13eb8481a4581fb9b9609dded6b4.jpeg" alt=""></p>
<p>右侧为已经创建的图表，使用鼠标拖拽即可将图标移动到网页上</p>
<h3 id="5-1改变图表大小">5.1改变图表大小</h3>
<p>鼠标移动到图表的右侧或者下侧时，鼠标会变成特殊符号，此时按住鼠标进行拖拽即可改变图表大小</p>
<h3 id="5-2各种布局元素的使用">5.2各种布局元素的使用</h3>
<p>除了自制图表，自助分析平台会提供6种预设布局元素，以供使用</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/521d43a74b06a5b5beca601866c691c8.jpeg" alt=""></p>
<p>从上到下的功能依次为</p>
<p><strong>tabs</strong>： 将其放置于页面上时会创建一行信息，这行中可以创建多个sheet页，每一页可以填充不同的图表，每一个sheet页均可命名</p>
<p><strong>row</strong>：可以创建一行空行，通常与column元素一起使用，达到一行中有多层的效果</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/d1b51f76ff440e33f231a612a0eb2c97.jpeg" alt=""></p>
<p><strong>Header</strong>：在页面上为单独一行，可以作为标题行使用</p>
<p><strong>text</strong>：一块页面组件，大小初始默认和自制的图表大致相同，但是里面可以填充markdown语法，并且可以分别展示代码形式和预览形式</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/051bf5f30e070fef0e288e36d56908ca.jpeg" alt=""></p>
<p><strong>divider</strong>：在页面中以一条直线展示，可以作为分隔符使用</p>
<p>编辑完成后点击右上角的save按键，即可保存页面效果</p>
<p>有一点需要注意的，成型的页面只会默认创建页面的时候拉取一次数据并展示，后期不会主动拉取数据进行分析展示，如果想要展示，则需要右上角的…，除了可以点击refresh dashboard进行一次手动刷新数据外，可以点击set auto-fresh interval按键选择自动刷新的时间间隔，选择哪一个可以根据业务需求</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/192963847f13b2c8ac7b1c59e70ee7fb.jpeg" alt=""></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/f3ebd4622ec5bc6c93cd31f5aea421fa.jpeg" alt=""></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">annabergite</span>
  </div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

  <script type="text/javascript" src='https://unpkg.com/mermaid@9.0.0/dist/mermaid.min.js'></script>
  <script>
  if (window.mermaid) {
        var mermaid_config = {
            startOnLoad: true,
            theme: '[object Object]',
            flowchart:{
                useMaxWidth: false,
                htmlLabels: true
            }                
        }
        mermaid.initialize(mermaid_config);
  }
  </script>
  
    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
